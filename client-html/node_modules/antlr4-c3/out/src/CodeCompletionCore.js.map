{"version":3,"file":"CodeCompletionCore.js","sourceRoot":"","sources":["../../src/CodeCompletionCore.ts"],"names":[],"mappings":"AAOA,YAAY,CAAC;;AAEb,uCAAkG;AAClG,sCAA2K;AAC3K,wCAA4C;AAO5C,MAAa,oBAAoB;IAAjC;QACW,WAAM,GAA2B,IAAI,GAAG,EAAE,CAAC;QAC3C,UAAK,GAA0B,IAAI,GAAG,EAAE,CAAC;IACpD,CAAC;CAAA;AAHD,oDAGC;AAAA,CAAC;AAOF,MAAM,iBAAiB;IAAvB;QAEW,SAAI,GAAa,EAAE,CAAC;QACpB,cAAS,GAAc,EAAE,CAAC;IACrC,CAAC;CAAA;AAAA,CAAC;AAKF,MAAM,gBAAgB;CAGrB;AAAA,CAAC;AAOF,MAAM,aAAa;CAGlB;AAAA,CAAC;AAGF,MAAa,kBAAkB;IA6B3B,YAAY,MAAc;QA3BnB,eAAU,GAAG,KAAK,CAAC;QACnB,oBAAe,GAAG,KAAK,CAAC;QACxB,+BAA0B,GAAG,KAAK,CAAC;QACnC,kBAAa,GAAG,KAAK,CAAC;QAcrB,oBAAe,GAAW,CAAC,CAAC;QAC5B,oBAAe,GAAW,CAAC,CAAC;QAI5B,gBAAW,GAA4C,IAAI,GAAG,EAAE,CAAC;QACjE,eAAU,GAAyB,IAAI,oBAAoB,EAAE,CAAC;QAwb9D,oBAAe,GAAa;YAChC,SAAS;YACT,OAAO;YACP,YAAY;YACZ,aAAa;YACb,kBAAkB;YAClB,kBAAkB;YAClB,aAAa;YACb,WAAW;YACX,WAAW;YACX,gBAAgB;YAChB,iBAAiB;YACjB,gBAAgB;YAChB,UAAU;SACb,CAAA;QAjcG,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,GAAG,GAAG,MAAM,CAAC,GAAG,CAAC;QACtB,IAAI,CAAC,UAAU,GAAG,MAAM,CAAC,UAAU,CAAC;QACpC,IAAI,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,CAAC;QAClC,IAAI,CAAC,aAAa,GAAG,IAAI,GAAG,EAAE,CAAC;QAC/B,IAAI,CAAC,cAAc,GAAG,IAAI,GAAG,EAAE,CAAC;IACpC,CAAC;IAQM,iBAAiB,CAAC,eAAuB,EAAE,OAA2B;QACzE,IAAI,CAAC,WAAW,CAAC,KAAK,EAAE,CAAC;QACzB,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;QAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;QAC/B,IAAI,CAAC,eAAe,GAAG,CAAC,CAAC;QACzB,IAAI,CAAC,eAAe,GAAG,EAAE,CAAC;QAE1B,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;QAC9D,IAAI,WAAW,GAAgB,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC;QAEvD,IAAI,YAAY,GAAG,WAAW,CAAC,KAAK,CAAC;QACrC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;QACvC,IAAI,CAAC,MAAM,GAAG,EAAE,CAAC;QACjB,IAAI,MAAM,GAAG,CAAC,CAAC;QACf,OAAO,IAAI,EAAE;YACT,IAAI,KAAK,GAAG,WAAW,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,CAAC;YACrC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAC7B,IAAI,KAAK,CAAC,UAAU,IAAI,eAAe,IAAI,KAAK,CAAC,IAAI,IAAI,gBAAK,CAAC,GAAG;gBAC9D,MAAM;SACb;QACD,WAAW,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAE/B,IAAI,SAAS,GAAa,EAAE,CAAC;QAC7B,IAAI,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;QAChD,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,GAAG,CAAC,gBAAgB,CAAC,SAAS,CAAC,EAAE,CAAC,EAAE,SAAS,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAE3E,IAAI,IAAI,CAAC,UAAU,EAAE;YACjB,OAAO,CAAC,GAAG,CAAC,oBAAoB,GAAG,IAAI,CAAC,eAAe,CAAC,CAAC;YACzD,OAAO,CAAC,GAAG,CAAC,wBAAwB,CAAC,CAAC;YACtC,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;gBACpC,IAAI,IAAI,GAAG,EAAE,CAAC;gBACd,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,EAAE;oBACvB,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,GAAG,CAAC;iBACvC;gBACD,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,UAAU,EAAE,IAAI,CAAC,CAAC;aAC3D;YAED,IAAI,YAAY,GAAgB,IAAI,GAAG,EAAE,CAAC;YAC1C,KAAK,IAAI,KAAK,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE;gBACtC,IAAI,KAAK,GAAW,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC7D,KAAK,IAAI,SAAS,IAAI,KAAK,CAAC,CAAC,CAAC;oBAC1B,KAAK,IAAI,GAAG,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;gBAC7D,YAAY,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;aAC3B;YAED,OAAO,CAAC,GAAG,CAAC,yBAAyB,CAAC,CAAC;YACvC,KAAK,IAAI,MAAM,IAAI,YAAY,EAAE;gBAC7B,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;aACvB;YACD,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;SACvB;QAED,OAAO,IAAI,CAAC,UAAU,CAAC;IAC3B,CAAC;IAKO,cAAc,CAAC,UAA+B;QAClD,OAAO,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,EAAE,4BAAiB,CAAC,YAAY,EAAE,CAAC,CAAC;IACpF,CAAC;IAMO,oBAAoB,CAAC,SAAmB;QAC5C,IAAI,IAAI,CAAC,cAAc,CAAC,IAAI,IAAI,CAAC;YAC7B,OAAO,KAAK,CAAC;QAIjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;YACvC,IAAI,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,EAAE;gBAGvC,IAAI,IAAI,GAAG,SAAS,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;gBACjC,IAAI,MAAM,GAAG,IAAI,CAAC;gBAClB,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,UAAU,CAAC,KAAK,EAAE;oBACpC,IAAI,IAAI,CAAC,CAAC,CAAC,IAAI,SAAS,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC,CAAC,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM;wBACxD,SAAS;oBAEb,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;wBACxC,MAAM,GAAG,KAAK,CAAC;wBACf,MAAM;qBACT;iBACJ;gBAED,IAAI,MAAM,EAAE;oBACR,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;oBAC9C,IAAI,IAAI,CAAC,eAAe;wBACpB,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;iBAC5D;gBACD,OAAO,IAAI,CAAC;aACf;SACJ;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAMO,kBAAkB,CAAC,UAAsB;QAC7C,IAAI,MAAM,GAAa,EAAE,CAAC;QAE1B,IAAI,IAAI,GAAe,EAAE,CAAC;QAC1B,IAAI,QAAQ,GAAe,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAE/C,OAAO,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;YACxB,IAAI,KAAK,GAAG,QAAQ,CAAC,GAAG,EAAE,CAAC;YAE3B,KAAK,IAAI,UAAU,IAAI,KAAM,CAAC,cAAc,EAAE,EAAE;gBAC5C,IAAI,UAAU,CAAC,iBAAiB,KAAuB,EAAE;oBACrD,IAAI,CAAC,UAAU,CAAC,SAAS,EAAE;wBACvB,IAAI,IAAI,GAAG,UAAU,CAAC,KAAM,CAAC,OAAO,EAAE,CAAC;wBACvC,IAAI,IAAI,CAAC,MAAM,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;4BACtD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;4BACrB,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;yBACpC;qBACJ;yBAAM;wBACH,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;qBACpC;iBACJ;aACJ;SACJ;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAKO,mBAAmB,CAAC,KAAe,EAAE,IAAc;QACvD,IAAI,MAAM,GAAwB,EAAE,CAAC;QACrC,IAAI,IAAI,GAAkB,IAAI,GAAG,EAAE,CAAC;QACpC,IAAI,SAAS,GAAa,EAAE,CAAC;QAC7B,IAAI,CAAC,iBAAiB,CAAC,KAAK,EAAE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;QAE7D,OAAO,MAAM,CAAC;IAClB,CAAC;IAMO,iBAAiB,CAAC,CAAW,EAAE,SAAmB,EAAE,UAA+B,EAAE,IAAmB,EAAE,SAAmB;QAEjI,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;YACX,OAAO;QAEX,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;QAEZ,IAAI,CAAC,IAAI,SAAS,IAAI,CAAC,CAAC,SAAS,IAAI,kBAAY,CAAC,SAAS,EAAE;YACzD,IAAI,GAAG,GAAG,IAAI,iBAAiB,EAAE,CAAC;YAClC,GAAG,CAAC,SAAS,GAAG,kBAAW,CAAC,EAAE,CAAC,gBAAK,CAAC,OAAO,CAAC,CAAC;YAC9C,GAAG,CAAC,IAAI,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC;YAC7B,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;YACrB,OAAO;SACV;QAED,KAAK,IAAI,UAAU,IAAI,CAAC,CAAC,cAAc,EAAE,EAAE;YACvC,IAAI,UAAU,CAAC,iBAAiB,KAAuB,EAAE;gBACrD,IAAI,cAAc,GAAmB,UAA4B,CAAC;gBAClE,IAAI,SAAS,CAAC,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;oBACxD,SAAS;gBAEb,SAAS,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;gBAChD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;gBAClF,SAAS,CAAC,GAAG,EAAE,CAAC;aAEnB;iBAAM,IAAI,UAAU,CAAC,iBAAiB,KAA4B,EAAE;gBACjE,IAAI,IAAI,CAAC,cAAc,CAAC,UAAiC,CAAC;oBACtD,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;aACzF;iBAAM,IAAI,UAAU,CAAC,SAAS,EAAE;gBAC7B,IAAI,CAAC,iBAAiB,CAAC,UAAU,CAAC,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;aACrF;iBAAM,IAAI,UAAU,CAAC,iBAAiB,KAA2B,EAAE;gBAChE,IAAI,GAAG,GAAG,IAAI,iBAAiB,EAAE,CAAC;gBAClC,GAAG,CAAC,SAAS,GAAG,kBAAW,CAAC,EAAE,CAAC,gBAAK,CAAC,mBAAmB,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;gBACjF,GAAG,CAAC,IAAI,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC;gBAC7B,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;aACxB;iBAAM;gBACH,IAAI,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC;gBAC7B,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,GAAG,CAAC,EAAE;oBACzB,IAAI,UAAU,CAAC,iBAAiB,KAA0B,EAAE;wBACxD,KAAK,GAAG,KAAK,CAAC,UAAU,CAAC,kBAAW,CAAC,EAAE,CAAC,gBAAK,CAAC,mBAAmB,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC;qBAC9F;oBACD,IAAI,GAAG,GAAG,IAAI,iBAAiB,EAAE,CAAC;oBAClC,GAAG,CAAC,SAAS,GAAG,KAAK,CAAC;oBACtB,GAAG,CAAC,IAAI,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC;oBAC7B,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC;oBACpD,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;iBACxB;aACJ;SACJ;IACL,CAAC;IAOO,WAAW,CAAC,UAA0B,EAAE,UAAkB,EAAE,SAAmB,EAAE,UAAkB,EACvG,WAAmB;QAKnB,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QAC7D,IAAI,CAAC,WAAW,EAAE;YACd,WAAW,GAAG,IAAI,GAAG,EAAE,CAAC;YACxB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,SAAS,EAAE,WAAW,CAAC,CAAC;SAC3D;aAAM;YACH,IAAI,WAAW,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE;gBAC7B,IAAI,IAAI,CAAC,eAAe,EAAE;oBACtB,OAAO,CAAC,GAAG,CAAC,iBAAiB,CAAC,CAAC;iBAClC;gBACD,OAAO,WAAW,CAAC,GAAG,CAAC,UAAU,CAAE,CAAC;aACvC;SACJ;QAED,IAAI,MAAM,GAAkB,IAAI,GAAG,EAAU,CAAC;QAS9C,IAAI,YAAY,GAAG,kBAAkB,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QACxF,IAAI,CAAC,YAAY,EAAE;YACf,YAAY,GAAG,IAAI,GAAG,EAAE,CAAC;YACzB,kBAAkB,CAAC,eAAe,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;SACtF;QAED,IAAI,UAAU,GAAG,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,CAAC,CAAC;QAC1D,IAAI,CAAC,UAAU,EAAE;YACb,UAAU,GAAG,IAAI,gBAAgB,EAAE,CAAC;YACpC,YAAY,CAAC,GAAG,CAAC,UAAU,CAAC,WAAW,EAAE,UAAU,CAAC,CAAC;YACrD,IAAI,IAAI,GAAG,IAAI,CAAC,GAAG,CAAC,eAAe,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;YAC1D,UAAU,CAAC,IAAI,GAAG,IAAI,CAAC,mBAAmB,CAAC,UAAU,EAAE,IAAI,CAAC,CAAC;YAI7D,IAAI,QAAQ,GAAG,IAAI,kBAAW,EAAE,CAAC;YACjC,KAAK,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI;gBAC3B,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;YACnC,UAAU,CAAC,QAAQ,GAAG,QAAQ,CAAC;SAClC;QAED,SAAS,CAAC,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;QACrC,IAAI,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACtC,IAAI,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;gBAE/C,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,CAAC;aACxC;iBAAM;gBAGH,KAAK,IAAI,GAAG,IAAI,UAAU,CAAC,IAAI,EAAE;oBAC7B,IAAI,QAAQ,GAAG,SAAS,CAAC,KAAK,EAAE,CAAC;oBACjC,QAAQ,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,IAAI,CAAC,CAAC;oBAC3B,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,QAAQ,CAAC,EAAE;wBACtC,KAAK,IAAI,MAAM,IAAI,GAAG,CAAC,SAAS,CAAC,OAAO,EAAE;4BACtC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;gCACjC,IAAI,IAAI,CAAC,eAAe,EAAE;oCACtB,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;iCAC7E;gCACD,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC;oCACnC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,SAAS,CAAC,CAAC;qCACjD;oCAED,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,SAAS;wCACnD,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;iCAC9C;6BACJ;qBACR;iBACJ;aACJ;YAED,SAAS,CAAC,GAAG,EAAE,CAAC;YAChB,OAAO,MAAM,CAAC;SAEjB;aAAM;YAIH,IAAI,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;YAC5C,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,gBAAK,CAAC,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;gBAC9F,SAAS,CAAC,GAAG,EAAE,CAAC;gBAChB,OAAO,MAAM,CAAC;aACjB;SACJ;QAED,IAAI,UAAU,CAAC,gBAAgB,EAAE;YAC7B,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;SACzC;QAID,IAAI,aAAa,GAAoB,EAAE,CAAC;QACxC,IAAI,YAAY,CAAC;QAGjB,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,CAAC,CAAC;QAElE,OAAO,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;YAC7B,YAAY,GAAG,aAAa,CAAC,GAAG,EAAG,CAAC;YACpC,EAAE,IAAI,CAAC,eAAe,CAAC;YAEvB,IAAI,aAAa,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;YAEzD,IAAI,OAAO,GAAG,YAAY,CAAC,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;YAChE,IAAI,IAAI,CAAC,eAAe,EAAE;gBACtB,IAAI,CAAC,gBAAgB,CAAC,WAAW,EAAE,YAAY,CAAC,KAAK,EAAE,IAAI,CAAC,uBAAuB,CAAC,YAAY,CAAC,KAAK,CAAC,EACnG,YAAY,CAAC,UAAU,CAAC,CAAC;gBAC7B,IAAI,IAAI,CAAC,aAAa;oBAClB,IAAI,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC;aACtC;YAED,IAAI,YAAY,CAAC,KAAK,CAAC,SAAS,IAAI,kBAAY,CAAC,SAAS,EAAE;gBAExD,MAAM,CAAC,GAAG,CAAC,YAAY,CAAC,UAAU,CAAC,CAAC;gBACpC,SAAS;aACZ;YAED,IAAI,WAAW,GAAG,YAAY,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC;YAItD,KAAK,IAAI,UAAU,IAAI,WAAW,EAAE;gBAChC,QAAQ,UAAU,CAAC,iBAAiB,EAAE;oBAClC,MAAwB,CAAC,CAAC;wBACtB,IAAI,cAAc,GAAG,UAA4B,CAAC;wBAClD,IAAI,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,MAAwB,EAAE,YAAY,CAAC,UAAU,EACzF,SAAS,EAAE,cAAc,CAAC,UAAU,EAAE,WAAW,GAAG,CAAC,CAAC,CAAC;wBAC3D,KAAK,IAAI,QAAQ,IAAI,SAAS,EAAE;4BAC5B,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAmB,UAAW,CAAC,WAAW,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAC,CAAC;yBACjG;wBACD,MAAM;qBACT;oBAED,MAA6B,CAAC,CAAC;wBAC3B,IAAI,IAAI,CAAC,cAAc,CAAC,UAAiC,CAAC;4BACtD,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;wBAC1F,MAAM;qBACT;oBAED,OAA8B,CAAC,CAAC;wBAC5B,MAAM,cAAc,GAAG,UAA2C,CAAC;wBACnE,IAAI,cAAc,CAAC,UAAU,IAAI,IAAI,CAAC,eAAe,CAAC,IAAI,CAAC,eAAe,CAAC,MAAM,GAAG,CAAC,CAAC;4BAClF,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;wBAE1F,MAAM;qBACT;oBAED,MAA4B,CAAC,CAAC;wBAC1B,IAAI,OAAO,EAAE;4BACT,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,EAAE;gCACvC,KAAK,IAAI,KAAK,IAAI,kBAAW,CAAC,EAAE,CAAC,gBAAK,CAAC,mBAAmB,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,OAAO,EAAE;oCACxF,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,KAAK,CAAC;wCAC9B,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;6BACjD;yBACJ;6BAAM;4BACH,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,CAAC,UAAU,GAAG,CAAC,EAAE,CAAC,CAAC;yBAC7F;wBACD,MAAM;qBACT;oBAED,OAAO,CAAC,CAAC;wBACL,IAAI,UAAU,CAAC,SAAS,EAAE;4BAEtB,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,CAAC,UAAU,EAAE,CAAC,CAAC;4BACtF,SAAS;yBACZ;wBAED,IAAI,GAAG,GAAG,UAAU,CAAC,KAAK,CAAC;wBAC3B,IAAI,GAAG,IAAI,GAAG,CAAC,IAAI,GAAG,CAAC,EAAE;4BACrB,IAAI,UAAU,CAAC,iBAAiB,KAA0B,EAAE;gCACxD,GAAG,GAAG,GAAG,CAAC,UAAU,CAAC,kBAAW,CAAC,EAAE,CAAC,gBAAK,CAAC,mBAAmB,EAAE,IAAI,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC;6BAC1F;4BACD,IAAI,OAAO,EAAE;gCACT,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,SAAS,CAAC,EAAE;oCACvC,IAAI,IAAI,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;oCACzB,IAAI,YAAY,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,CAAC;oCACpC,KAAK,IAAI,MAAM,IAAI,IAAI;wCACnB,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;4CACjC,IAAI,IAAI,CAAC,eAAe;gDACpB,OAAO,CAAC,GAAG,CAAC,oBAAoB,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC;4CAE9E,IAAI,YAAY;gDACZ,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,CAAC;;gDAExE,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;yCAC9C;iCACR;6BACJ;iCAAM;gCACH,IAAI,GAAG,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;oCAC7B,IAAI,IAAI,CAAC,eAAe;wCACpB,OAAO,CAAC,GAAG,CAAC,mBAAmB,EAAE,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC;oCACpF,aAAa,CAAC,IAAI,CAAC,EAAE,KAAK,EAAE,UAAU,CAAC,MAAM,EAAE,UAAU,EAAE,YAAY,CAAC,UAAU,GAAG,CAAC,EAAE,CAAC,CAAC;iCAC7F;6BACJ;yBACJ;qBACJ;iBACJ;aACJ;SACJ;QAED,SAAS,CAAC,GAAG,EAAE,CAAC;QAChB,IAAI,UAAU,CAAC,gBAAgB,EAAE;YAC7B,IAAI,CAAC,eAAe,CAAC,GAAG,EAAE,CAAC;SAC9B;QAGD,WAAW,CAAC,GAAG,CAAC,UAAU,EAAE,MAAM,CAAC,CAAC;QAEpC,OAAO,MAAM,CAAC;IAClB,CAAC;IAkBO,uBAAuB,CAAC,KAAe;QAC3C,IAAI,UAAU,GAAG,KAAK,CAAC,WAAW,IAAI,cAAQ,CAAC,oBAAoB,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC;QACpG,OAAO,GAAG,GAAG,UAAU,GAAG,GAAG,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,SAAS,CAAC,GAAG,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC;IACtH,CAAC;IAEO,gBAAgB,CAAC,WAAmB,EAAE,KAAe,EAAE,eAAuB,EAAE,UAAkB;QAEtG,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QACxC,IAAI,MAAM,GAAG,MAAM,CAAC;QAEpB,IAAI,qBAAqB,GAAG,EAAE,CAAC;QAC/B,IAAI,IAAI,CAAC,0BAA0B,EAAE;YACjC,KAAK,IAAI,UAAU,IAAI,KAAK,CAAC,cAAc,EAAE,EAAE;gBAC3C,IAAI,MAAM,GAAG,EAAE,CAAC;gBAChB,IAAI,OAAO,GAAa,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,UAAU,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC3E,IAAI,OAAO,CAAC,MAAM,GAAG,CAAC,EAAE;oBAEpB,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAG,MAAM,GAAG,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;iBAC9H;qBAAM;oBACH,KAAK,IAAI,MAAM,IAAI,OAAO,EAAE;wBACxB,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC;4BACjB,MAAM,IAAI,IAAI,CAAC;wBACnB,MAAM,IAAI,IAAI,CAAC,UAAU,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;qBACpD;iBACJ;gBACD,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC;oBAClB,MAAM,GAAG,GAAG,CAAC;gBACjB,qBAAqB,IAAI,IAAI,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG,IAAI,GAAG,GAAG,GAAG,UAAU,CAAC,MAAM,CAAC,WAAW,GAAG,GAAG;oBACtG,IAAI,CAAC,eAAe,CAAC,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,OAAO,GAAG,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;aACjH;SACJ;QAED,IAAI,UAAU,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC;YACpC,MAAM,IAAI,IAAI,GAAG,IAAI,CAAC,eAAe,GAAG,UAAU,GAAG,KAAK,CAAC;;YAE3D,MAAM,IAAI,GAAG,GAAG,IAAI,CAAC,eAAe,GAAG,UAAU,GAAG,IAAI,CAAC;QAC7D,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,iBAAiB,GAAG,eAAe,GAAG,qBAAqB,CAAC,CAAC;IACtF,CAAC;IAEO,cAAc,CAAC,KAAe;QAClC,IAAI,KAAK,CAAC,MAAM,IAAI,CAAC,EAAE;YACnB,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,CAAC;YAC7B,OAAO;SACV;QAED,KAAK,IAAI,IAAI,IAAI,KAAK;YAClB,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;IAC1C,CAAC;;AArfc,kCAAe,GAAoC,IAAI,GAAG,EAAE,CAAC;AA3BhF,gDAkhBC","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2016, 2017, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n'use strict';\n\nimport { Parser, Vocabulary, Token, TokenStream, RuleContext, ParserRuleContext } from 'antlr4ts';\nimport { ATN, ATNState, ATNStateType, Transition, TransitionType, PredicateTransition, RuleTransition, RuleStartState, PrecedencePredicateTransition } from 'antlr4ts/atn';\nimport { IntervalSet } from 'antlr4ts/misc';\n\nexport type TokenList = number[];\nexport type RuleList = number[];\n\n// All the candidates which have been found. Tokens and rules are separated (both use a numeric value).\n// Token entries include a list of tokens that directly follow them (see also the \"following\" member in the FollowSetWithPath class).\nexport class CandidatesCollection {\n    public tokens: Map<number, TokenList> = new Map();\n    public rules: Map<number, RuleList> = new Map();\n};\n\n// A record for a follow set along with the path at which this set was found.\n// If there is only a single symbol in the interval set then we also collect and store tokens which follow\n// this symbol directly in its rule (i.e. there is no intermediate rule transition). Only single label transitions\n// are considered. This is useful if you have a chain of tokens which can be suggested as a whole, because there is\n// a fixed sequence in the grammar.\nclass FollowSetWithPath {\n    public intervals: IntervalSet;\n    public path: RuleList = [];\n    public following: TokenList = [];\n};\n\n// A list of follow sets (for a given state number) + all of them combined for quick hit tests.\n// This data is static in nature (because the used ATN states are part of a static struct: the ATN).\n// Hence it can be shared between all C3 instances, however it depends on the actual parser class (type).\nclass FollowSetsHolder {\n    public sets: FollowSetWithPath[];\n    public combined: IntervalSet;\n};\n\ntype FollowSetsPerState = Map<number, FollowSetsHolder>;\n\n// Token stream position info after a rule was processed.\ntype RuleEndStatus = Set<number>;\n\nclass PipelineEntry {\n    state: ATNState;\n    tokenIndex: number;\n};\n\n// The main class for doing the collection process.\nexport class CodeCompletionCore {\n    // Debugging options. Print human readable ATN state and other info.\n    public showResult = false;                 // Not dependent on showDebugOutput. Prints the collected rules + tokens to terminal.\n    public showDebugOutput = false;            // Enables printing ATN state info to terminal.\n    public debugOutputWithTransitions = false; // Only relevant when showDebugOutput is true. Enables transition printing for a state.\n    public showRuleStack = false;              // Also depends on showDebugOutput. Enables call stack printing for each rule recursion.\n\n    // Tailoring of the result.\n    public ignoredTokens: Set<number>;        // Tokens which should not appear in the candidates set.\n    public preferredRules: Set<number>;       // Rules which replace any candidate token they contain.\n                                              // This allows to return descriptive rules (e.g. className, instead of ID/identifier).\n\n    private parser: Parser;\n    private atn: ATN;\n    private vocabulary: Vocabulary;\n    private ruleNames: string[];\n    private tokens: TokenList;\n    private precedenceStack: Array<number>;\n\n    private tokenStartIndex: number = 0;\n    private statesProcessed: number = 0;\n\n    // A mapping of rule index + token stream position to end token positions.\n    // A rule which has been visited before with the same input position will always produce the same output positions.\n    private shortcutMap: Map<number, Map<number, RuleEndStatus>> = new Map();\n    private candidates: CandidatesCollection = new CandidatesCollection(); // The collected candidates (rules and tokens).\n\n    private static followSetsByATN: Map<string, FollowSetsPerState> = new Map();\n\n    constructor(parser: Parser) {\n        this.parser = parser;\n        this.atn = parser.atn;\n        this.vocabulary = parser.vocabulary;\n        this.ruleNames = parser.ruleNames;\n        this.ignoredTokens = new Set();\n        this.preferredRules = new Set();\n    }\n\n    /**\n     * This is the main entry point. The caret token index specifies the token stream index for the token which currently\n     * covers the caret (or any other position you want to get code completion candidates for).\n     * Optionally you can pass in a parser rule context which limits the ATN walk to only that or called rules. This can significantly\n     * speed up the retrieval process but might miss some candidates (if they are outside of the given context).\n     */\n    public collectCandidates(caretTokenIndex: number, context?: ParserRuleContext): CandidatesCollection {\n        this.shortcutMap.clear();\n        this.candidates.rules.clear();\n        this.candidates.tokens.clear();\n        this.statesProcessed = 0;\n        this.precedenceStack = [];\n\n        this.tokenStartIndex = context ? context.start.tokenIndex : 0;\n        let tokenStream: TokenStream = this.parser.inputStream;\n\n        let currentIndex = tokenStream.index;\n        tokenStream.seek(this.tokenStartIndex);\n        this.tokens = [];\n        let offset = 1;\n        while (true) {\n            let token = tokenStream.LT(offset++);\n            this.tokens.push(token.type);\n            if (token.tokenIndex >= caretTokenIndex || token.type == Token.EOF)\n                break;\n        }\n        tokenStream.seek(currentIndex);\n\n        let callStack: number[] = [];\n        let startRule = context ? context.ruleIndex : 0;\n        this.processRule(this.atn.ruleToStartState[startRule], 0, callStack, 0, 0);\n\n        if (this.showResult) {\n            console.log(\"States processed: \" + this.statesProcessed);\n            console.log(\"\\n\\nCollected rules:\\n\");\n            for (let rule of this.candidates.rules) {\n                let path = \"\";\n                for (let token of rule[1]) {\n                    path += this.ruleNames[token] + \" \";\n                }\n                console.log(this.ruleNames[rule[0]] + \", path: \", path);\n            }\n\n            let sortedTokens: Set<string> = new Set();\n            for (let token of this.candidates.tokens) {\n                let value: string = this.vocabulary.getDisplayName(token[0]);\n                for (let following of token[1])\n                    value += \" \" + this.vocabulary.getDisplayName(following);\n                sortedTokens.add(value);\n            }\n\n            console.log(\"\\n\\nCollected tokens:\\n\");\n            for (let symbol of sortedTokens) {\n                console.log(symbol);\n            }\n            console.log(\"\\n\\n\");\n        }\n\n        return this.candidates;\n    }\n\n    /**\n     * Checks if the predicate associated with the given transition evaluates to true.\n     */\n    private checkPredicate(transition: PredicateTransition): boolean {\n        return transition.predicate.eval(this.parser, ParserRuleContext.emptyContext());\n    }\n\n    /**\n     * Walks the rule chain upwards to see if that matches any of the preferred rules.\n     * If found, that rule is added to the collection candidates and true is returned.\n     */\n    private translateToRuleIndex(ruleStack: RuleList): boolean {\n        if (this.preferredRules.size == 0)\n            return false;\n\n        // Loop over the rule stack from highest to lowest rule level. This way we properly handle the higher rule\n        // if it contains a lower one that is also a preferred rule.\n        for (let i = 0; i < ruleStack.length; ++i) {\n            if (this.preferredRules.has(ruleStack[i])) {\n                // Add the rule to our candidates list along with the current rule path,\n                // but only if there isn't already an entry like that.\n                let path = ruleStack.slice(0, i);\n                let addNew = true;\n                for (let rule of this.candidates.rules) {\n                    if (rule[0] != ruleStack[i] || rule[1].length != path.length)\n                        continue;\n                    // Found an entry for this rule. Same path? If so don't add a new (duplicate) entry.\n                    if (path.every((v, j) => v === rule[1][j])) {\n                        addNew = false;\n                        break;\n                    }\n                }\n\n                if (addNew) {\n                    this.candidates.rules.set(ruleStack[i], path);\n                    if (this.showDebugOutput)\n                        console.log(\"=====> collected: \", this.ruleNames[i]);\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * This method follows the given transition and collects all symbols within the same rule that directly follow it\n     * without intermediate transitions to other rules and only if there is a single symbol for a transition.\n     */\n    private getFollowingTokens(transition: Transition): number[] {\n        let result: number[] = [];\n\n        let seen: ATNState[] = [];\n        let pipeline: ATNState[] = [transition.target];\n\n        while (pipeline.length > 0) {\n            let state = pipeline.pop();\n\n            for (let transition of state!.getTransitions()) {\n                if (transition.serializationType == TransitionType.ATOM) {\n                    if (!transition.isEpsilon) {\n                        let list = transition.label!.toArray();\n                        if (list.length == 1 && !this.ignoredTokens.has(list[0])) {\n                            result.push(list[0]);\n                            pipeline.push(transition.target);\n                        }\n                    } else {\n                        pipeline.push(transition.target);\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Entry point for the recursive follow set collection function.\n     */\n    private determineFollowSets(start: ATNState, stop: ATNState): FollowSetWithPath[] {\n        let result: FollowSetWithPath[] = [];\n        let seen: Set<ATNState> = new Set();\n        let ruleStack: number[] = [];\n        this.collectFollowSets(start, stop, result, seen, ruleStack);\n\n        return result;\n    }\n\n    /**\n     * Collects possible tokens which could be matched following the given ATN state. This is essentially the same\n     * algorithm as used in the LL1Analyzer class, but here we consider predicates also and use no parser rule context.\n     */\n    private collectFollowSets(s: ATNState, stopState: ATNState, followSets: FollowSetWithPath[], seen: Set<ATNState>, ruleStack: number[]) {\n\n        if (seen.has(s))\n            return;\n\n        seen.add(s);\n\n        if (s == stopState || s.stateType == ATNStateType.RULE_STOP) {\n            let set = new FollowSetWithPath();\n            set.intervals = IntervalSet.of(Token.EPSILON);\n            set.path = ruleStack.slice();\n            followSets.push(set);\n            return;\n        }\n\n        for (let transition of s.getTransitions()) {\n            if (transition.serializationType == TransitionType.RULE) {\n                let ruleTransition: RuleTransition = transition as RuleTransition;\n                if (ruleStack.indexOf(ruleTransition.target.ruleIndex) != -1)\n                    continue;\n\n                ruleStack.push(ruleTransition.target.ruleIndex);\n                this.collectFollowSets(transition.target, stopState, followSets, seen, ruleStack);\n                ruleStack.pop();\n\n            } else if (transition.serializationType == TransitionType.PREDICATE) {\n                if (this.checkPredicate(transition as PredicateTransition))\n                    this.collectFollowSets(transition.target, stopState, followSets, seen, ruleStack);\n            } else if (transition.isEpsilon) {\n                this.collectFollowSets(transition.target, stopState, followSets, seen, ruleStack);\n            } else if (transition.serializationType == TransitionType.WILDCARD) {\n                let set = new FollowSetWithPath();\n                set.intervals = IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                set.path = ruleStack.slice();\n                followSets.push(set);\n            } else {\n                let label = transition.label;\n                if (label && label.size > 0) {\n                    if (transition.serializationType == TransitionType.NOT_SET) {\n                        label = label.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                    }\n                    let set = new FollowSetWithPath();\n                    set.intervals = label;\n                    set.path = ruleStack.slice();\n                    set.following = this.getFollowingTokens(transition);\n                    followSets.push(set);\n                }\n            }\n        }\n    }\n\n    /**\n     * Walks the ATN for a single rule only. It returns the token stream position for each path that could be matched in this rule.\n     * The result can be empty in case we hit only non-epsilon transitions that didn't match the current input or if we\n     * hit the caret position.\n     */\n    private processRule(startState: RuleStartState, tokenIndex: number, callStack: number[], precedence: number,\n        indentation: number): RuleEndStatus {\n\n        // Start with rule specific handling before going into the ATN walk.\n\n        // Check first if we've taken this path with the same input before.\n        let positionMap = this.shortcutMap.get(startState.ruleIndex);\n        if (!positionMap) {\n            positionMap = new Map();\n            this.shortcutMap.set(startState.ruleIndex, positionMap);\n        } else {\n            if (positionMap.has(tokenIndex)) {\n                if (this.showDebugOutput) {\n                    console.log(\"=====> shortcut\");\n                }\n                return positionMap.get(tokenIndex)!;\n            }\n        }\n\n        let result: RuleEndStatus = new Set<number>();\n\n        // For rule start states we determine and cache the follow set, which gives us 3 advantages:\n        // 1) We can quickly check if a symbol would be matched when we follow that rule. We can so check in advance\n        //    and can save us all the intermediate steps if there is no match.\n        // 2) We'll have all symbols that are collectable already together when we are at the caret when entering a rule.\n        // 3) We get this lookup for free with any 2nd or further visit of the same rule, which often happens\n        //    in non trivial grammars, especially with (recursive) expressions and of course when invoking code completion\n        //    multiple times.\n        let setsPerState = CodeCompletionCore.followSetsByATN.get(this.parser.constructor.name);\n        if (!setsPerState) {\n            setsPerState = new Map();\n            CodeCompletionCore.followSetsByATN.set(this.parser.constructor.name, setsPerState);\n        }\n\n        let followSets = setsPerState.get(startState.stateNumber);\n        if (!followSets) {\n            followSets = new FollowSetsHolder();\n            setsPerState.set(startState.stateNumber, followSets);\n            let stop = this.atn.ruleToStopState[startState.ruleIndex];\n            followSets.sets = this.determineFollowSets(startState, stop);\n\n            // Sets are split by path to allow translating them to preferred rules. But for quick hit tests\n            // it is also useful to have a set with all symbols combined.\n            let combined = new IntervalSet();\n            for (let set of followSets.sets)\n                combined.addAll(set.intervals);\n            followSets.combined = combined;\n        }\n\n        callStack.push(startState.ruleIndex);\n        if (tokenIndex >= this.tokens.length - 1) { // At caret?\n            if (this.preferredRules.has(startState.ruleIndex)) {\n                // No need to go deeper when collecting entries and we reach a rule that we want to collect anyway.\n                this.translateToRuleIndex(callStack);\n            } else {\n                // Convert all follow sets to either single symbols or their associated preferred rule and add\n                // the result to our candidates list.\n                for (let set of followSets.sets) {\n                    let fullPath = callStack.slice();\n                    fullPath.push(...set.path);\n                    if (!this.translateToRuleIndex(fullPath)) {\n                        for (let symbol of set.intervals.toArray())\n                            if (!this.ignoredTokens.has(symbol)) {\n                                if (this.showDebugOutput) {\n                                    console.log(\"=====> collected: \", this.vocabulary.getDisplayName(symbol));\n                                }\n                                if (!this.candidates.tokens.has(symbol))\n                                    this.candidates.tokens.set(symbol, set.following); // Following is empty if there is more than one entry in the set.\n                                else {\n                                    // More than one following list for the same symbol.\n                                    if (this.candidates.tokens.get(symbol) != set.following)\n                                        this.candidates.tokens.set(symbol, []);\n                                }\n                            }\n                    }\n                }\n            }\n\n            callStack.pop();\n            return result;\n\n        } else {\n            // Process the rule if we either could pass it without consuming anything (epsilon transition)\n            // or if the current input symbol will be matched somewhere after this entry point.\n            // Otherwise stop here.\n            let currentSymbol = this.tokens[tokenIndex];\n            if (!followSets.combined.contains(Token.EPSILON) && !followSets.combined.contains(currentSymbol)) {\n                callStack.pop();\n                return result;\n            }\n        }\n\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.push(precedence);\n        }\n\n        // The current state execution pipeline contains all yet-to-be-processed ATN states in this rule.\n        // For each such state we store the token index + a list of rules that lead to it.\n        let statePipeline: PipelineEntry[] = [];\n        let currentEntry;\n\n        // Bootstrap the pipeline.\n        statePipeline.push({ state: startState, tokenIndex: tokenIndex });\n\n        while (statePipeline.length > 0) {\n            currentEntry = statePipeline.pop()!;\n            ++this.statesProcessed;\n\n            let currentSymbol = this.tokens[currentEntry.tokenIndex];\n\n            let atCaret = currentEntry.tokenIndex >= this.tokens.length - 1;\n            if (this.showDebugOutput) {\n                this.printDescription(indentation, currentEntry.state, this.generateBaseDescription(currentEntry.state),\n                    currentEntry.tokenIndex);\n                if (this.showRuleStack)\n                    this.printRuleState(callStack);\n            }\n\n            if (currentEntry.state.stateType == ATNStateType.RULE_STOP) {\n                // Record the token index we are at, to report it to the caller.\n                result.add(currentEntry.tokenIndex);\n                continue;\n            }\n\n            let transitions = currentEntry.state.getTransitions();\n\n            // We simulate here the same precedence handling as the parser does, which uses hard coded values.\n            // For rules that are not left recursive this value is ignored (since there is no precedence transition).\n            for (let transition of transitions) {\n                switch (transition.serializationType) {\n                    case TransitionType.RULE: {\n                        let ruleTransition = transition as RuleTransition;\n                        let endStatus = this.processRule(transition.target as RuleStartState, currentEntry.tokenIndex,\n                            callStack, ruleTransition.precedence, indentation + 1);\n                        for (let position of endStatus) {\n                            statePipeline.push({ state: (<RuleTransition>transition).followState, tokenIndex: position });\n                        }\n                        break;\n                    }\n\n                    case TransitionType.PREDICATE: {\n                        if (this.checkPredicate(transition as PredicateTransition))\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex });\n                        break;\n                    }\n\n                    case TransitionType.PRECEDENCE: {\n                        const predTransition = transition as PrecedencePredicateTransition;\n                        if (predTransition.precedence >= this.precedenceStack[this.precedenceStack.length - 1])\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex });\n\n                        break;\n                    }\n\n                    case TransitionType.WILDCARD: {\n                        if (atCaret) {\n                            if (!this.translateToRuleIndex(callStack)) {\n                                for (let token of IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType).toArray())\n                                    if (!this.ignoredTokens.has(token))\n                                        this.candidates.tokens.set(token, []);\n                            }\n                        } else {\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex + 1 });\n                        }\n                        break;\n                    }\n\n                    default: {\n                        if (transition.isEpsilon) {\n                            // Jump over simple states with a single outgoing epsilon transition.\n                            statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex });\n                            continue;\n                        }\n\n                        let set = transition.label;\n                        if (set && set.size > 0) {\n                            if (transition.serializationType == TransitionType.NOT_SET) {\n                                set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                            }\n                            if (atCaret) {\n                                if (!this.translateToRuleIndex(callStack)) {\n                                    let list = set.toArray();\n                                    let addFollowing = list.length == 1;\n                                    for (let symbol of list)\n                                        if (!this.ignoredTokens.has(symbol)) {\n                                            if (this.showDebugOutput)\n                                                console.log(\"=====> collected: \", this.vocabulary.getDisplayName(symbol));\n\n                                            if (addFollowing)\n                                                this.candidates.tokens.set(symbol, this.getFollowingTokens(transition));\n                                            else\n                                                this.candidates.tokens.set(symbol, []);\n                                        }\n                                }\n                            } else {\n                                if (set.contains(currentSymbol)) {\n                                    if (this.showDebugOutput)\n                                        console.log(\"=====> consumed: \", this.vocabulary.getDisplayName(currentSymbol));\n                                    statePipeline.push({ state: transition.target, tokenIndex: currentEntry.tokenIndex + 1 });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        callStack.pop();\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.pop();\n        }\n\n        // Cache the result, for later lookup to avoid duplicate walks.\n        positionMap.set(tokenIndex, result);\n\n        return result;\n    }\n\n    private atnStateTypeMap: string[] = [\n        \"invalid\",\n        \"basic\",\n        \"rule start\",\n        \"block start\",\n        \"plus block start\",\n        \"star block start\",\n        \"token start\",\n        \"rule stop\",\n        \"block end\",\n        \"star loop back\",\n        \"star loop entry\",\n        \"plus loop back\",\n        \"loop end\"\n    ]\n\n    private generateBaseDescription(state: ATNState): string {\n        let stateValue = state.stateNumber == ATNState.INVALID_STATE_NUMBER ? \"Invalid\" : state.stateNumber;\n        return \"[\" + stateValue + \" \" + this.atnStateTypeMap[state.stateType] + \"] in \" + this.ruleNames[state.ruleIndex];\n    }\n\n    private printDescription(indentation: number, state: ATNState, baseDescription: string, tokenIndex: number) {\n\n        const indent = \"  \".repeat(indentation);\n        let output = indent;\n\n        let transitionDescription = \"\";\n        if (this.debugOutputWithTransitions) {\n            for (let transition of state.getTransitions()) {\n                let labels = \"\";\n                let symbols: number[] = transition.label ? transition.label.toArray() : [];\n                if (symbols.length > 2) {\n                    // Only print start and end symbols to avoid large lists in debug output.\n                    labels = this.vocabulary.getDisplayName(symbols[0]) + \" .. \" + this.vocabulary.getDisplayName(symbols[symbols.length - 1]);\n                } else {\n                    for (let symbol of symbols) {\n                        if (labels.length > 0)\n                            labels += \", \";\n                        labels += this.vocabulary.getDisplayName(symbol);\n                    }\n                }\n                if (labels.length == 0)\n                    labels = \"Îµ\";\n                transitionDescription += \"\\n\" + indent + \"\\t(\" + labels + \") \" + \"[\" + transition.target.stateNumber + \" \" +\n                    this.atnStateTypeMap[transition.target.stateType] + \"] in \" + this.ruleNames[transition.target.ruleIndex];\n            }\n        }\n\n        if (tokenIndex >= this.tokens.length - 1)\n            output += \"<<\" + this.tokenStartIndex + tokenIndex + \">> \";\n        else\n            output += \"<\" + this.tokenStartIndex + tokenIndex + \"> \";\n        console.log(output + \"Current state: \" + baseDescription + transitionDescription);\n    }\n\n    private printRuleState(stack: number[]) {\n        if (stack.length == 0) {\n            console.log(\"<empty stack>\");\n            return;\n        }\n\n        for (let rule of stack)\n            console.log(this.ruleNames[rule]);\n    }\n\n}\n"]}