{"version":3,"file":"SymbolTable.js","sourceRoot":"","sources":["../../src/SymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2017, 2019, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n'use strict';\n\nimport { ParseTree } from 'antlr4ts/tree/ParseTree';\n\nexport class DuplicateSymbolError extends Error { };\n\nexport enum MemberVisibility {\n    Invalid = -1,\n    Public = 0,\n    Protected,\n    Private,\n    Library,\n};\n\nexport enum TypeKind {\n    Integer,\n    Float,\n    String,\n    Boolean,\n    Date,\n\n    Class,\n    Array,\n    Alias,\n};\n\nexport enum ReferenceKind {\n    Irrelevant,\n    Pointer,   // Default for most languages for dynamically allocated memory (\"Type*\" in C++).\n    Reference, // \"Type&\" in C++\n    Instance,  // \"Type\" as such and default for all value types.\n}\n\n// The root type interface. Used for typed symbols and type aliases.\nexport interface Type {\n    name: string;\n\n    // The super type of this type or empty if this is a fundamental type.\n    // Also used as the target type for type aliases.\n    baseTypes: Type[];\n    kind: TypeKind;\n    reference: ReferenceKind;\n};\n\nexport interface SymbolTableOptions {\n    allowDuplicateSymbols?: boolean;\n}\n\n// A single class for all fundamental types. They are distinguished via the kind field.\nexport class FundamentalType implements Type {\n    public name: string;\n\n    public get baseTypes(): Type[] { return []; }\n    public get kind(): TypeKind { return this.typeKind; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public static readonly integerType: FundamentalType = new FundamentalType(\"int\", TypeKind.Integer, ReferenceKind.Instance);\n    public static readonly floatType: FundamentalType = new FundamentalType(\"float\", TypeKind.Float, ReferenceKind.Instance);\n    public static readonly stringType: FundamentalType = new FundamentalType(\"string\", TypeKind.String, ReferenceKind.Instance);\n    public static readonly boolType: FundamentalType = new FundamentalType(\"bool\", TypeKind.Boolean, ReferenceKind.Instance);\n    public static readonly dateType: FundamentalType = new FundamentalType(\"date\", TypeKind.Date, ReferenceKind.Instance);\n\n    constructor(name: string, typeKind: TypeKind, referenceKind: ReferenceKind) {\n        this.name = name;\n        this.typeKind = typeKind;\n        this.referenceKind = referenceKind;\n    }\n\n    private typeKind: TypeKind;\n    private referenceKind: ReferenceKind;\n}\n\n// The root of the symbol table class hierarchy: a symbol can be any manageable entity (like a block), not only\n// things like variables or classes.\n// We are using a class hierarchy here, instead of an enum or similar, to allow for easy extension and certain\n// symbols can so provide additional APIs for simpler access to their sub elements, if needed.\nexport class Symbol {\n    public name: string = \"\"; // The name of the scope or empty if anonymous.\n    public context: ParseTree | undefined; // Reference to the parse tree which contains this symbol.\n\n    constructor(name: string = \"\") {\n        this.name = name;\n    }\n\n    /**\n     * The parent is usually a scoped symbol as only those can have children, but we allow\n     * any symbol here for special scenarios.\n     * This is rather an internal method and should rarely be used by external code.\n     */\n    public setParent(parent: Symbol | undefined) {\n        this._parent = parent;\n    }\n\n    public get parent(): Symbol | undefined {\n        return this._parent;\n    }\n\n    public get firstSibling(): Symbol {\n        if (this._parent instanceof ScopedSymbol) {\n            return this._parent.firstChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the symbol before this symbol in its scope.\n     */\n    public get previousSibling(): Symbol | undefined {\n        if (!(this._parent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        let result = this._parent.previousSiblingOf(this);\n        if (result) {\n            return result;\n        }\n    }\n\n    /**\n     * Returns the symbol following this symbol in its scope.\n     */\n    public get nextSibling(): Symbol | undefined {\n        if (!(this._parent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        let result = this._parent.nextSiblingOf(this);\n        if (result) {\n            return result;\n        }\n    }\n\n    public get lastSibling(): Symbol {\n        if (this._parent instanceof ScopedSymbol) {\n            return this._parent.lastChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * Returns the next symbol in definition order, regardless of the scope.\n     */\n    public get next(): Symbol | undefined {\n        if (this.parent instanceof ScopedSymbol) {\n            return this.parent.nextOf(this);\n        }\n    }\n\n    public removeFromParent() {\n        if (this._parent instanceof ScopedSymbol) {\n            this._parent.removeSymbol(this);\n            this._parent = undefined;\n        }\n    }\n\n    /**\n     * Returns the first symbol with a given name, in the order of appearance in this scope\n     * or any of the parent scopes (conditionally).\n     */\n    public resolve(name: string, localOnly = false): Symbol | undefined {\n        if (this._parent instanceof ScopedSymbol) {\n            return this._parent.resolve(name, localOnly);\n        }\n    }\n\n    /**\n     * Get the outermost entity (below the symbol table) that holds us.\n     */\n    public get root(): Symbol | undefined {\n        let run = this._parent;\n        while (run) {\n            if (!run._parent || (run._parent instanceof SymbolTable))\n                return run;\n            run = run._parent;\n        }\n        return run;\n    }\n\n    /**\n     * Returns the symbol table we belong too or undefined if we are not yet assigned.\n     */\n    public get symbolTable(): SymbolTable | undefined {\n        if (this instanceof SymbolTable) {\n            return this;\n        }\n\n        let run = this._parent;\n        while (run) {\n            if (run instanceof SymbolTable)\n                return run;\n            run = run._parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns the next enclosing parent of the given type.\n     */\n    public getParentOfType<T extends Symbol>(t: new (...args: any[]) => T): T | undefined {\n        let run = this._parent;\n        while (run) {\n            if (run instanceof t)\n                return <T>run;\n            run = run._parent;\n        }\n        return undefined;\n    }\n\n    /**\n     * The list of symbols from this one up to root.\n     */\n    public get symbolPath(): Symbol[] {\n        let result: Symbol[] = [];\n        let run: Symbol = this;\n        while (run) {\n            result.push(run);\n            if (!run._parent)\n                break;\n            run = run._parent;\n        }\n        return result;\n    }\n\n    /**\n     * Creates a qualified identifier from this symbol and its parent.\n     * If `full` is true then all parents are traversed in addition to this instance.\n     */\n    public qualifiedName(separator = \".\", full = false, includeAnonymous = false): string {\n        if (!includeAnonymous && this.name.length == 0)\n            return \"\";\n\n        let result: string = this.name.length == 0 ? \"<anonymous>\" : this.name;\n        let run = this._parent;\n        while (run) {\n            if (includeAnonymous || run.name.length > 0) {\n                result = (run.name.length == 0 ? \"<anonymous>\" : run.name) + separator + result;\n                if (!full || !run._parent)\n                    break;\n            }\n            run = run._parent;\n        }\n        return result;\n    }\n\n    protected _parent: Symbol | undefined;\n};\n\n// A symbol with an attached type (variables, fields etc.).\nexport class TypedSymbol extends Symbol {\n    public type: Type | undefined;\n\n    constructor(name: string, type?: Type) {\n        super(name);\n        this.type = type;\n    }\n};\n\n// An alias for another type.\nexport class TypeAlias extends Symbol implements Type {\n    public get baseTypes(): Type[] { return [this.targetType]; }\n    public get kind(): TypeKind { return TypeKind.Alias; }\n    public get reference(): ReferenceKind { return ReferenceKind.Irrelevant; }\n\n    constructor(name: string, target: Type) {\n        super(name);\n        this.targetType = target;\n    }\n\n    private targetType: Type;\n};\n\n// A symbol with a scope (so it can have child symbols).\nexport class ScopedSymbol extends Symbol {\n    constructor(name = \"\") {\n        super(name)\n    }\n\n    public get children() {\n        return this._children;\n    }\n\n    public clear() {\n        this._children = [];\n    }\n\n    /**\n     * Adds the given symbol to this scope. If it belongs already to a different scope\n     * it is removed from that before adding it here.\n     */\n    public addSymbol(symbol: Symbol) {\n        symbol.removeFromParent();\n\n        // Check for duplicates first.\n        let symbolTable = this.symbolTable;\n        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {\n            for (let child of this._children) {\n                if (child == symbol || (symbol.name.length > 0 && child.name == symbol.name)) {\n                    let name = symbol.name;\n                    if (name.length == 0)\n                        name = \"<anonymous>\";\n                    throw new DuplicateSymbolError(\"Attempt to add duplicate symbol '\" + name + \"'\");\n                }\n            }\n        }\n\n        this._children.push(symbol);\n        symbol.setParent(this);\n    }\n\n    public removeSymbol(symbol: Symbol) {\n        let index = this._children.indexOf(symbol);\n        if (index > -1) {\n            this._children.splice(index, 1);\n            symbol.setParent(undefined);\n        }\n    }\n\n    /**\n     * Returns all (nested) children of a given type.\n     */\n    public getNestedSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): T[] {\n        let result: T[] = [];\n\n        for (let child of this._children) {\n            if (child instanceof t)\n                result.push(child);\n            if (child instanceof ScopedSymbol)\n                result.push(...child.getNestedSymbolsOfType(t));\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns symbols from this and all nested scopes in the order they were defined.\n     * @param name If given only returns symbols with that name.\n     */\n    public getAllNestedSymbols(name?: string): Symbol[] {\n        let result: Symbol[] = [];\n\n        for (let child of this._children) {\n            if (!name || child.name == name) {\n                result.push(child);\n            }\n            if (child instanceof ScopedSymbol)\n                result.push(...child.getAllNestedSymbols(name));\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns direct children of a given type.\n     */\n    public getSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): T[] {\n        let result: T[] = [];\n        for (let child of this._children) {\n            if (child instanceof t)\n                result.push(<T>child);\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns all symbols of the the given type, accessible from this scope (if localOnly is false),\n     * within the owning symbol table.\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     */\n    public getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): Set<Symbol> {\n        let result: Set<Symbol> = new Set();\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (let child of this._children) {\n            if (child instanceof t) {\n                result.add(child);\n            }\n            if (child instanceof NamespaceSymbol) {\n                child.getAllSymbols(t, true).forEach(result.add, result);\n            }\n        }\n\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol) {\n                this._parent.getAllSymbols(t, true).forEach(result.add, result);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the first symbol with a given name, in the order of appearance in this scope\n     * or any of the parent scopes (conditionally).\n     */\n    public resolve(name: string, localOnly = false): Symbol | undefined {\n        for (let child of this._children) {\n            if (child.name == name)\n                return child;\n        }\n\n        // Nothing found locally. Let the parent continue.\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol)\n                return this._parent.resolve(name, false);\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Returns all accessible symbols that have a type assigned.\n     */\n    public getTypedSymbols(localOnly = true): TypedSymbol[] {\n        let result: TypedSymbol[] = []\n\n        for (let child of this._children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child);\n            }\n        }\n\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol) {\n                let localList = (this._parent as ScopedSymbol).getTypedSymbols(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * The names of all accessible symbols with a type.\n     */\n    public getTypedSymbolNames(localOnly = true): string[] {\n        let result: string[] = [];\n        for (let child of this._children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child.name);\n            }\n        }\n\n        if (!localOnly) {\n            if (this._parent instanceof ScopedSymbol) {\n                let localList = (this._parent as ScopedSymbol).getTypedSymbolNames(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns all direct child symbols with a scope (e.g. classes in a module).\n     */\n    public get directScopes(): ScopedSymbol[] {\n        return this.getSymbolsOfType(ScopedSymbol);\n    }\n\n    /**\n     * Returns the symbol located at the given path through the symbol hierarchy.\n     * @param path The path consisting of symbol names separator by `separator`.\n     * @param separator The character to separate path segments.\n     */\n    public symbolFromPath(path: string, separator: string = \".\"): Symbol | undefined {\n        let elements = path.split(separator);\n        let index = 0;\n        if (elements[0] == this.name || elements[0].length == 0)\n            ++index;\n\n        let result: Symbol = this;\n        while (index < elements.length) {\n            if (!(result instanceof ScopedSymbol)) // Some parts left but found a non-scoped symbol?\n                return undefined;\n\n            let child = result._children.find(child => child.name == elements[index]);\n            if (!child)\n                return undefined;\n            result = child;\n            ++index;\n        }\n        return result;\n    }\n\n    /**\n     * Returns the index of the given child symbol in the child list or -1 if it couldn't be found.\n     */\n    public indexOfChild(child: Symbol): number {\n        return this._children.findIndex((value: Symbol, index: number) => {\n            return value == child;\n        });\n    }\n\n    /**\n     * Returns the sibling symbol after the given child symbol, if one exists.\n     */\n    public nextSiblingOf(child: Symbol): Symbol | undefined {\n        let index = this.indexOfChild(child);\n        if (index == -1 || index >= this._children.length - 1) {\n            return;\n        }\n        return this._children[index + 1];\n    }\n\n    /**\n     * Returns the sibling symbol before the given child symbol, if one exists.\n     */\n    public previousSiblingOf(child: Symbol): Symbol | undefined {\n        let index = this.indexOfChild(child);\n        if (index < 1) {\n            return;\n        }\n        return this._children[index - 1];\n    }\n\n    public get firstChild(): Symbol | undefined {\n        if (this._children.length > 0) {\n            return this._children[0];\n        }\n    }\n\n    public get lastChild(): Symbol | undefined {\n        if (this._children.length > 0) {\n            return this._children[this._children.length - 1];\n        }\n    }\n\n    /**\n     * Returns the next symbol in definition order, regardless of the scope.\n     */\n    public nextOf(child: Symbol): Symbol | undefined {\n        if (!(child.parent instanceof ScopedSymbol)) {\n            return;\n        }\n        if (child.parent != this) {\n            return child.parent.nextOf(child);\n        }\n\n        if (child instanceof ScopedSymbol && child.children.length > 0) {\n            return child.children[0];\n        }\n\n        let sibling = this.nextSiblingOf(child);\n        if (sibling) {\n            return sibling;\n        }\n\n        return (this.parent as ScopedSymbol).nextOf(this);\n    }\n\n    private _children: Symbol[] = []; // All child symbols in definition order.\n};\n\nexport class NamespaceSymbol extends ScopedSymbol {\n}\n\nexport class BlockSymbol extends ScopedSymbol {\n}\n\nexport class VariableSymbol extends TypedSymbol {\n    constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n        this.value = value;\n    }\n\n    value: any;\n};\n\nexport class LiteralSymbol extends TypedSymbol {\n    constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n        this.value = value;\n    }\n\n    readonly value: any;\n};\n\nexport class ParameterSymbol extends VariableSymbol { };\n\n// A standalone function/procedure/rule.\nexport class RoutineSymbol extends ScopedSymbol {\n    returnType: Type | undefined; // Can be null if result is void.\n\n    constructor(name: string, returnType: Type) {\n        super(name);\n        this.returnType = returnType;\n    }\n\n    public getVariables(localOnly = true): VariableSymbol[] {\n        return this.getSymbolsOfType(VariableSymbol);\n    }\n\n    public getParameters(localOnly = true): ParameterSymbol[] {\n        return this.getSymbolsOfType(ParameterSymbol);\n    }\n};\n\nexport enum MethodFlags {\n    None = 0,\n    Virtual = 1,\n    Const = 2,\n    Overwritten = 4,\n    SetterOrGetter = 8, // Distinguished by the return type.\n    Explicit = 16,      // Special flag used e.g. in C++ for explicit c-tors.\n};\n\n// A routine which belongs to a class or other outer container structure.\nexport class MethodSymbol extends RoutineSymbol {\n    public methodFlags = MethodFlags.None;\n    public visibility = MemberVisibility.Invalid;\n\n    constructor(name: string, returnType: Type) {\n        super(name, returnType);\n    }\n};\n\nexport class FieldSymbol extends VariableSymbol {\n    public visibility = MemberVisibility.Invalid;\n\n    public setter: MethodSymbol | undefined;\n    public getter: MethodSymbol | undefined;\n\n    constructor(name: string, type: Type) {\n        super(name, type);\n    }\n};\n\n// Classes and structs.\nexport class ClassSymbol extends ScopedSymbol implements Type {\n\n    public get baseTypes(): Type[] { return this.superClasses; };\n    public get kind(): TypeKind { return TypeKind.Class; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public isStruct = false;\n\n    /**\n     * Usually only one member, unless the language supports multiple inheritance.\n     */\n    public readonly superClasses: ClassSymbol[] = [];\n\n    constructor(name: string, referenceKind: ReferenceKind, ...superClass: ClassSymbol[]) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.superClasses.push(...superClass); // Standard case: a single super class.\n    }\n\n    /**\n     * Returns a list of all methods.\n     */\n    public getMethods(includeInherited = false): MethodSymbol[] {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    /**\n     * Returns all fields.\n     */\n    public getFields(includeInherited = false): FieldSymbol[] {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n\n    private referenceKind: ReferenceKind;\n};\n\nexport class ArrayType extends Symbol implements Type {\n\n    public get baseTypes(): Type[] { return []; };\n    public get kind(): TypeKind { return TypeKind.Array; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n\n    public readonly elementType: Type;\n    public readonly size: number; // > 0 if fixed length.\n\n    constructor(name: string, referenceKind: ReferenceKind, elemType: Type, size = 0) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.elementType = elemType;\n        this.size = size;\n    }\n\n    private referenceKind: ReferenceKind;\n};\n\n// The main class managing all the symbols for a top level entity like a file, library or similar.\nexport class SymbolTable extends ScopedSymbol {\n    constructor(name: string, public readonly options: SymbolTableOptions) {\n        super(name);\n    }\n\n    public clear() {\n        super.clear();\n        this.dependencies.clear();\n    }\n\n    public addDependencies(...tables: SymbolTable[]) {\n        tables.forEach((value, key) => {\n            this.dependencies.add(value);\n        });\n    }\n\n    public removeDependency(table: SymbolTable) {\n        if (this.dependencies.has(table)) {\n            this.dependencies.delete(table);\n        }\n    }\n\n    /**\n     * Returns instance informations, mostly relevant for unit testing.\n     */\n    public get info() {\n        return {\n            dependencyCount: this.dependencies.size,\n            symbolCount: this.children.length\n        };\n    }\n\n    public addNewSymbolOfType<T extends Symbol>(t: new (...args: any[]) => T,\n        parent: ScopedSymbol | undefined, ...args: any[]): T {\n\n        let result = new t(...args);\n        if (!parent || parent == this) {\n            this.addSymbol(result);\n        } else {\n            parent.addSymbol(result);\n        }\n        return result;\n    }\n\n    /**\n     * Adds a new namespace to the symbol table or the given parent. The path parameter specifies a single namespace name\n     * or a chain of namespaces (which can be e.g. \"outer.intermittant.inner.final\").\n     * If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n     * or you'll get a duplicate symbol error.\n     */\n    public addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string, delimiter = \".\"): NamespaceSymbol {\n        let parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent == undefined) ? this : parent;\n        while (i < parts.length - 1) {\n            let namespace = currentParent.resolve(parts[i], true) as NamespaceSymbol;\n            if (namespace == undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    public getAllSymbols<T extends Symbol>(t?: new (...args: any[]) => T, localOnly: boolean = false): Set<Symbol> {\n        let type = t ? t : Symbol;\n        let result = super.getAllSymbols(type, localOnly);\n\n        if (!localOnly) {\n            for (let dependency of this.dependencies) {\n                dependency.getAllSymbols(t, localOnly).forEach(result.add, result);\n            }\n        }\n\n        return result;\n    }\n\n    public symbolWithContext(context: ParseTree): Symbol | undefined {\n\n        function findRecursive(symbol: Symbol): Symbol | undefined {\n            if (symbol.context == context) {\n                return symbol;\n            }\n\n            if (symbol instanceof ScopedSymbol) {\n                for (let child of symbol.children) {\n                    let result = findRecursive(child);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n        }\n\n        let symbols = this.getAllSymbols(Symbol);\n        for (let symbol of symbols) {\n            let result = findRecursive(symbol);\n            if (result) {\n                return result;\n            }\n        }\n\n        for (let dependency of this.dependencies) {\n            symbols = dependency.getAllSymbols(Symbol);\n            for (let symbol of symbols) {\n                let result = findRecursive(symbol);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n    }\n\n    public resolve(name: string, localOnly = false): Symbol | undefined {\n        let result = super.resolve(name, localOnly);\n\n        if (!result && !localOnly) {\n            for (let dependency of this.dependencies) {\n                result = dependency.resolve(name, false);\n                if (result)\n                    break;\n            }\n        }\n\n        return result;\n    }\n\n    // Other symbol information available to this instance.\n    protected dependencies: Set<SymbolTable> = new Set();\n};\n"]}