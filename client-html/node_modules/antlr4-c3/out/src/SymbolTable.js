'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
class DuplicateSymbolError extends Error {
}
exports.DuplicateSymbolError = DuplicateSymbolError;
;
var MemberVisibility;
(function (MemberVisibility) {
    MemberVisibility[MemberVisibility["Invalid"] = -1] = "Invalid";
    MemberVisibility[MemberVisibility["Public"] = 0] = "Public";
    MemberVisibility[MemberVisibility["Protected"] = 1] = "Protected";
    MemberVisibility[MemberVisibility["Private"] = 2] = "Private";
    MemberVisibility[MemberVisibility["Library"] = 3] = "Library";
})(MemberVisibility = exports.MemberVisibility || (exports.MemberVisibility = {}));
;
var TypeKind;
(function (TypeKind) {
    TypeKind[TypeKind["Integer"] = 0] = "Integer";
    TypeKind[TypeKind["Float"] = 1] = "Float";
    TypeKind[TypeKind["String"] = 2] = "String";
    TypeKind[TypeKind["Boolean"] = 3] = "Boolean";
    TypeKind[TypeKind["Date"] = 4] = "Date";
    TypeKind[TypeKind["Class"] = 5] = "Class";
    TypeKind[TypeKind["Array"] = 6] = "Array";
    TypeKind[TypeKind["Alias"] = 7] = "Alias";
})(TypeKind = exports.TypeKind || (exports.TypeKind = {}));
;
var ReferenceKind;
(function (ReferenceKind) {
    ReferenceKind[ReferenceKind["Irrelevant"] = 0] = "Irrelevant";
    ReferenceKind[ReferenceKind["Pointer"] = 1] = "Pointer";
    ReferenceKind[ReferenceKind["Reference"] = 2] = "Reference";
    ReferenceKind[ReferenceKind["Instance"] = 3] = "Instance";
})(ReferenceKind = exports.ReferenceKind || (exports.ReferenceKind = {}));
;
class FundamentalType {
    constructor(name, typeKind, referenceKind) {
        this.name = name;
        this.typeKind = typeKind;
        this.referenceKind = referenceKind;
    }
    get baseTypes() { return []; }
    get kind() { return this.typeKind; }
    get reference() { return this.referenceKind; }
}
FundamentalType.integerType = new FundamentalType("int", TypeKind.Integer, ReferenceKind.Instance);
FundamentalType.floatType = new FundamentalType("float", TypeKind.Float, ReferenceKind.Instance);
FundamentalType.stringType = new FundamentalType("string", TypeKind.String, ReferenceKind.Instance);
FundamentalType.boolType = new FundamentalType("bool", TypeKind.Boolean, ReferenceKind.Instance);
FundamentalType.dateType = new FundamentalType("date", TypeKind.Date, ReferenceKind.Instance);
exports.FundamentalType = FundamentalType;
class Symbol {
    constructor(name = "") {
        this.name = "";
        this.name = name;
    }
    setParent(parent) {
        this._parent = parent;
    }
    get parent() {
        return this._parent;
    }
    get firstSibling() {
        if (this._parent instanceof ScopedSymbol) {
            return this._parent.firstChild;
        }
        return this;
    }
    get previousSibling() {
        if (!(this._parent instanceof ScopedSymbol)) {
            return this;
        }
        let result = this._parent.previousSiblingOf(this);
        if (result) {
            return result;
        }
    }
    get nextSibling() {
        if (!(this._parent instanceof ScopedSymbol)) {
            return this;
        }
        let result = this._parent.nextSiblingOf(this);
        if (result) {
            return result;
        }
    }
    get lastSibling() {
        if (this._parent instanceof ScopedSymbol) {
            return this._parent.lastChild;
        }
        return this;
    }
    get next() {
        if (this.parent instanceof ScopedSymbol) {
            return this.parent.nextOf(this);
        }
    }
    removeFromParent() {
        if (this._parent instanceof ScopedSymbol) {
            this._parent.removeSymbol(this);
            this._parent = undefined;
        }
    }
    resolve(name, localOnly = false) {
        if (this._parent instanceof ScopedSymbol) {
            return this._parent.resolve(name, localOnly);
        }
    }
    get root() {
        let run = this._parent;
        while (run) {
            if (!run._parent || (run._parent instanceof SymbolTable))
                return run;
            run = run._parent;
        }
        return run;
    }
    get symbolTable() {
        if (this instanceof SymbolTable) {
            return this;
        }
        let run = this._parent;
        while (run) {
            if (run instanceof SymbolTable)
                return run;
            run = run._parent;
        }
        return undefined;
    }
    getParentOfType(t) {
        let run = this._parent;
        while (run) {
            if (run instanceof t)
                return run;
            run = run._parent;
        }
        return undefined;
    }
    get symbolPath() {
        let result = [];
        let run = this;
        while (run) {
            result.push(run);
            if (!run._parent)
                break;
            run = run._parent;
        }
        return result;
    }
    qualifiedName(separator = ".", full = false, includeAnonymous = false) {
        if (!includeAnonymous && this.name.length == 0)
            return "";
        let result = this.name.length == 0 ? "<anonymous>" : this.name;
        let run = this._parent;
        while (run) {
            if (includeAnonymous || run.name.length > 0) {
                result = (run.name.length == 0 ? "<anonymous>" : run.name) + separator + result;
                if (!full || !run._parent)
                    break;
            }
            run = run._parent;
        }
        return result;
    }
}
exports.Symbol = Symbol;
;
class TypedSymbol extends Symbol {
    constructor(name, type) {
        super(name);
        this.type = type;
    }
}
exports.TypedSymbol = TypedSymbol;
;
class TypeAlias extends Symbol {
    get baseTypes() { return [this.targetType]; }
    get kind() { return TypeKind.Alias; }
    get reference() { return ReferenceKind.Irrelevant; }
    constructor(name, target) {
        super(name);
        this.targetType = target;
    }
}
exports.TypeAlias = TypeAlias;
;
class ScopedSymbol extends Symbol {
    constructor(name = "") {
        super(name);
        this._children = [];
    }
    get children() {
        return this._children;
    }
    clear() {
        this._children = [];
    }
    addSymbol(symbol) {
        symbol.removeFromParent();
        let symbolTable = this.symbolTable;
        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {
            for (let child of this._children) {
                if (child == symbol || (symbol.name.length > 0 && child.name == symbol.name)) {
                    let name = symbol.name;
                    if (name.length == 0)
                        name = "<anonymous>";
                    throw new DuplicateSymbolError("Attempt to add duplicate symbol '" + name + "'");
                }
            }
        }
        this._children.push(symbol);
        symbol.setParent(this);
    }
    removeSymbol(symbol) {
        let index = this._children.indexOf(symbol);
        if (index > -1) {
            this._children.splice(index, 1);
            symbol.setParent(undefined);
        }
    }
    getNestedSymbolsOfType(t) {
        let result = [];
        for (let child of this._children) {
            if (child instanceof t)
                result.push(child);
            if (child instanceof ScopedSymbol)
                result.push(...child.getNestedSymbolsOfType(t));
        }
        return result;
    }
    getAllNestedSymbols(name) {
        let result = [];
        for (let child of this._children) {
            if (!name || child.name == name) {
                result.push(child);
            }
            if (child instanceof ScopedSymbol)
                result.push(...child.getAllNestedSymbols(name));
        }
        return result;
    }
    getSymbolsOfType(t) {
        let result = [];
        for (let child of this._children) {
            if (child instanceof t)
                result.push(child);
        }
        return result;
    }
    getAllSymbols(t, localOnly = false) {
        let result = new Set();
        for (let child of this._children) {
            if (child instanceof t) {
                result.add(child);
            }
            if (child instanceof NamespaceSymbol) {
                child.getAllSymbols(t, true).forEach(result.add, result);
            }
        }
        if (!localOnly) {
            if (this._parent instanceof ScopedSymbol) {
                this._parent.getAllSymbols(t, true).forEach(result.add, result);
            }
        }
        return result;
    }
    resolve(name, localOnly = false) {
        for (let child of this._children) {
            if (child.name == name)
                return child;
        }
        if (!localOnly) {
            if (this._parent instanceof ScopedSymbol)
                return this._parent.resolve(name, false);
        }
        return undefined;
    }
    getTypedSymbols(localOnly = true) {
        let result = [];
        for (let child of this._children) {
            if (child instanceof TypedSymbol) {
                result.push(child);
            }
        }
        if (!localOnly) {
            if (this._parent instanceof ScopedSymbol) {
                let localList = this._parent.getTypedSymbols(true);
                result.push(...localList);
            }
        }
        return result;
    }
    getTypedSymbolNames(localOnly = true) {
        let result = [];
        for (let child of this._children) {
            if (child instanceof TypedSymbol) {
                result.push(child.name);
            }
        }
        if (!localOnly) {
            if (this._parent instanceof ScopedSymbol) {
                let localList = this._parent.getTypedSymbolNames(true);
                result.push(...localList);
            }
        }
        return result;
    }
    get directScopes() {
        return this.getSymbolsOfType(ScopedSymbol);
    }
    symbolFromPath(path, separator = ".") {
        let elements = path.split(separator);
        let index = 0;
        if (elements[0] == this.name || elements[0].length == 0)
            ++index;
        let result = this;
        while (index < elements.length) {
            if (!(result instanceof ScopedSymbol))
                return undefined;
            let child = result._children.find(child => child.name == elements[index]);
            if (!child)
                return undefined;
            result = child;
            ++index;
        }
        return result;
    }
    indexOfChild(child) {
        return this._children.findIndex((value, index) => {
            return value == child;
        });
    }
    nextSiblingOf(child) {
        let index = this.indexOfChild(child);
        if (index == -1 || index >= this._children.length - 1) {
            return;
        }
        return this._children[index + 1];
    }
    previousSiblingOf(child) {
        let index = this.indexOfChild(child);
        if (index < 1) {
            return;
        }
        return this._children[index - 1];
    }
    get firstChild() {
        if (this._children.length > 0) {
            return this._children[0];
        }
    }
    get lastChild() {
        if (this._children.length > 0) {
            return this._children[this._children.length - 1];
        }
    }
    nextOf(child) {
        if (!(child.parent instanceof ScopedSymbol)) {
            return;
        }
        if (child.parent != this) {
            return child.parent.nextOf(child);
        }
        if (child instanceof ScopedSymbol && child.children.length > 0) {
            return child.children[0];
        }
        let sibling = this.nextSiblingOf(child);
        if (sibling) {
            return sibling;
        }
        return this.parent.nextOf(this);
    }
}
exports.ScopedSymbol = ScopedSymbol;
;
class NamespaceSymbol extends ScopedSymbol {
}
exports.NamespaceSymbol = NamespaceSymbol;
class BlockSymbol extends ScopedSymbol {
}
exports.BlockSymbol = BlockSymbol;
class VariableSymbol extends TypedSymbol {
    constructor(name, value, type) {
        super(name, type);
        this.value = value;
    }
}
exports.VariableSymbol = VariableSymbol;
;
class LiteralSymbol extends TypedSymbol {
    constructor(name, value, type) {
        super(name, type);
        this.value = value;
    }
}
exports.LiteralSymbol = LiteralSymbol;
;
class ParameterSymbol extends VariableSymbol {
}
exports.ParameterSymbol = ParameterSymbol;
;
class RoutineSymbol extends ScopedSymbol {
    constructor(name, returnType) {
        super(name);
        this.returnType = returnType;
    }
    getVariables(localOnly = true) {
        return this.getSymbolsOfType(VariableSymbol);
    }
    getParameters(localOnly = true) {
        return this.getSymbolsOfType(ParameterSymbol);
    }
}
exports.RoutineSymbol = RoutineSymbol;
;
var MethodFlags;
(function (MethodFlags) {
    MethodFlags[MethodFlags["None"] = 0] = "None";
    MethodFlags[MethodFlags["Virtual"] = 1] = "Virtual";
    MethodFlags[MethodFlags["Const"] = 2] = "Const";
    MethodFlags[MethodFlags["Overwritten"] = 4] = "Overwritten";
    MethodFlags[MethodFlags["SetterOrGetter"] = 8] = "SetterOrGetter";
    MethodFlags[MethodFlags["Explicit"] = 16] = "Explicit";
})(MethodFlags = exports.MethodFlags || (exports.MethodFlags = {}));
;
class MethodSymbol extends RoutineSymbol {
    constructor(name, returnType) {
        super(name, returnType);
        this.methodFlags = MethodFlags.None;
        this.visibility = MemberVisibility.Invalid;
    }
}
exports.MethodSymbol = MethodSymbol;
;
class FieldSymbol extends VariableSymbol {
    constructor(name, type) {
        super(name, type);
        this.visibility = MemberVisibility.Invalid;
    }
}
exports.FieldSymbol = FieldSymbol;
;
class ClassSymbol extends ScopedSymbol {
    constructor(name, referenceKind, ...superClass) {
        super(name);
        this.isStruct = false;
        this.superClasses = [];
        this.referenceKind = referenceKind;
        this.superClasses.push(...superClass);
    }
    get baseTypes() { return this.superClasses; }
    ;
    get kind() { return TypeKind.Class; }
    get reference() { return this.referenceKind; }
    getMethods(includeInherited = false) {
        return this.getSymbolsOfType(MethodSymbol);
    }
    getFields(includeInherited = false) {
        return this.getSymbolsOfType(FieldSymbol);
    }
}
exports.ClassSymbol = ClassSymbol;
;
class ArrayType extends Symbol {
    get baseTypes() { return []; }
    ;
    get kind() { return TypeKind.Array; }
    get reference() { return this.referenceKind; }
    constructor(name, referenceKind, elemType, size = 0) {
        super(name);
        this.referenceKind = referenceKind;
        this.elementType = elemType;
        this.size = size;
    }
}
exports.ArrayType = ArrayType;
;
class SymbolTable extends ScopedSymbol {
    constructor(name, options) {
        super(name);
        this.options = options;
        this.dependencies = new Set();
    }
    clear() {
        super.clear();
        this.dependencies.clear();
    }
    addDependencies(...tables) {
        tables.forEach((value, key) => {
            this.dependencies.add(value);
        });
    }
    removeDependency(table) {
        if (this.dependencies.has(table)) {
            this.dependencies.delete(table);
        }
    }
    get info() {
        return {
            dependencyCount: this.dependencies.size,
            symbolCount: this.children.length
        };
    }
    addNewSymbolOfType(t, parent, ...args) {
        let result = new t(...args);
        if (!parent || parent == this) {
            this.addSymbol(result);
        }
        else {
            parent.addSymbol(result);
        }
        return result;
    }
    addNewNamespaceFromPath(parent, path, delimiter = ".") {
        let parts = path.split(delimiter);
        let i = 0;
        let currentParent = (parent == undefined) ? this : parent;
        while (i < parts.length - 1) {
            let namespace = currentParent.resolve(parts[i], true);
            if (namespace == undefined) {
                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);
            }
            currentParent = namespace;
            ++i;
        }
        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);
    }
    getAllSymbols(t, localOnly = false) {
        let type = t ? t : Symbol;
        let result = super.getAllSymbols(type, localOnly);
        if (!localOnly) {
            for (let dependency of this.dependencies) {
                dependency.getAllSymbols(t, localOnly).forEach(result.add, result);
            }
        }
        return result;
    }
    symbolWithContext(context) {
        function findRecursive(symbol) {
            if (symbol.context == context) {
                return symbol;
            }
            if (symbol instanceof ScopedSymbol) {
                for (let child of symbol.children) {
                    let result = findRecursive(child);
                    if (result) {
                        return result;
                    }
                }
            }
        }
        let symbols = this.getAllSymbols(Symbol);
        for (let symbol of symbols) {
            let result = findRecursive(symbol);
            if (result) {
                return result;
            }
        }
        for (let dependency of this.dependencies) {
            symbols = dependency.getAllSymbols(Symbol);
            for (let symbol of symbols) {
                let result = findRecursive(symbol);
                if (result) {
                    return result;
                }
            }
        }
    }
    resolve(name, localOnly = false) {
        let result = super.resolve(name, localOnly);
        if (!result && !localOnly) {
            for (let dependency of this.dependencies) {
                result = dependency.resolve(name, false);
                if (result)
                    break;
            }
        }
        return result;
    }
}
exports.SymbolTable = SymbolTable;
;
//# sourceMappingURL=SymbolTable.js.map