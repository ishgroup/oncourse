<?xml version="1.0" encoding="UTF-8" ?>
<config>
    <luceneMatchVersion>8.9.0</luceneMatchVersion>

    <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.StandardDirectoryFactory}"/>
    <schemaFactory class="ClassicIndexSchemaFactory"/>


    <indexConfig>
        <writeLockTimeout>20000</writeLockTimeout>
        <maxIndexingThreads>8</maxIndexingThreads>
        <useCompoundFile>false</useCompoundFile>
        <ramBufferSizeMB>32</ramBufferSizeMB>
        <maxBufferedDocs>1000</maxBufferedDocs>

        <mergePolicyFactory class="org.apache.solr.index.TieredMergePolicyFactory"/>

        <mergeScheduler class="org.apache.lucene.index.ConcurrentMergeScheduler"/>

        <lockType>simple</lockType>
        
        <reopenReaders>true</reopenReaders>

        <deletionPolicy class="solr.SolrDeletionPolicy">
            <str name="maxCommitsToKeep">1</str>
            <str name="maxOptimizedCommitsToKeep">0</str>
        </deletionPolicy>

        <!-- Lucene Infostream
        To aid in advanced debugging, Lucene provides an "InfoStream"
        of detailed information when indexing.

        Setting The value to true will instruct the underlying Lucene
        IndexWriter to write its debugging info the specified file
        -->
        <infoStream file="INFOSTREAM.txt">false</infoStream>

        <!-- maxFieldLength was removed in 4.0. To get similar behavior, include a
             LimitTokenCountFilterFactory in your fieldType definition. E.g.
         <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="10000"/>
        -->
    </indexConfig>
    
    <!-- the default high-performance update handler -->
    <updateHandler class="solr.DirectUpdateHandler2">

        <updateLog>
            <str name="dir">${solr.ulog.dir:}</str>
            <int name="numVersionBuckets">${solr.ulog.numVersionBuckets:65536}</int>
        </updateLog>

        <autoCommit>
            <maxTime>15000</maxTime>
            <openSearcher>false</openSearcher>
        </autoCommit>
    </updateHandler>

    <query>
        <maxBooleanClauses>1024</maxBooleanClauses>
        <filterCache
                class="solr.FastLRUCache"
                size="512"
                initialSize="512"
                autowarmCount="0"/>

        <queryResultCache
                class="solr.LRUCache"
                size="512"
                initialSize="512"
                autowarmCount="0"/>

        <documentCache
                class="solr.LRUCache"
                size="512"
                initialSize="512"
                autowarmCount="0"/>

        <enableLazyFieldLoading>true</enableLazyFieldLoading>
        <queryResultWindowSize>20</queryResultWindowSize>
        <queryResultMaxDocsCached>200</queryResultMaxDocsCached>

        <listener event="newSearcher" class="solr.QuerySenderListener">
            <arr name="queries">
            </arr>
        </listener>

        <listener event="firstSearcher" class="solr.QuerySenderListener">
            <arr name="queries">
            </arr>
        </listener>

        <useColdSearcher>false</useColdSearcher>
        <maxWarmingSearchers>2</maxWarmingSearchers>

    </query>

    <!--
      Let the dispatch filter handler /select?qt=XXX
      handleSelect=true will use consistent error handling for /select and /update
      handleSelect=false will use solr1.1 style error formatting
      -->
    <requestDispatcher handleSelect="true">
        <!--Make sure your system has some authentication before enabling remote streaming!  -->
        <requestParsers enableRemoteStreaming="true" multipartUploadLimitInKB="2048000"/>

        <!-- Set HTTP caching related parameters (for proxy caches and clients).

             To get the behaviour of Solr 1.2 (ie: no caching related headers)
             use the never304="true" option and do not specify a value for
             <cacheControl>
        -->
        <!-- <httpCaching never304="true"> -->
        <httpCaching lastModifiedFrom="openTime"
                     etagSeed="Solr">
            <!-- lastModFrom="openTime" is the default, the Last-Modified value
                 (and validation against If-Modified-Since requests) will all be
                 relative to when the current Searcher was opened.
                 You can change it to lastModFrom="dirLastMod" if you want the
                 value to exactly corrispond to when the physical index was last
                 modified.

                 etagSeed="..." is an option you can change to force the ETag
                 header (and validation against If-None-Match requests) to be
                 differnet even if the index has not changed (ie: when making
                 significant changes to your config file)

                 lastModifiedFrom and etagSeed are both ignored if you use the
                 never304="true" option.
            -->
            <!-- If you include a <cacheControl> directive, it will be used to
                 generate a Cache-Control header, as well as an Expires header
                 if the value contains "max-age="

                 By default, no Cache-Control header is generated.

                 You can use the <cacheControl> option even if you have set
                 never304="true"
            -->
            <!-- <cacheControl>max-age=30, public</cacheControl> -->
        </httpCaching>
    </requestDispatcher>


    <!-- requestHandler plugins... incoming queries will be dispatched to the
       correct handler based on the path or the qt (query type) param.
       Names starting with a '/' are accessed with the a path equal to the
       registered name.  Names without a leading '/' are accessed with:
        http://host/app/select?qt=name
       If no qt is defined, the requestHandler that declares default="true"
       will be used.
    -->
    <requestHandler name="standard" class="solr.SearchHandler" default="true">
        <!-- default values for query parameters -->
        <lst name="defaults">
            <str name="echoParams">explicit</str>
            <str name="df">id</str>
            <int name="rows">10</int>
        </lst>
    </requestHandler>

    <!--
    -->
    <requestHandler name="/browse" class="solr.SearchHandler">
        <lst name="defaults">

            <!-- VelocityResponseWriter settings -->
            <str name="wt">velocity</str>
            <str name="v.template">browse</str>
            <str name="v.layout">layout</str>
            <str name="title">Solritas</str>

            <!-- Query settings -->
            <str name="defType">edismax</str>
            <str name="qf">course_id^30 code^10 classSuburb^5 classPostcode^5 tutor^5 when^5</str>
            <str name="q.alt">*:*</str>
            <str name="rows">10</str>
            <str name="fl">*,score</str>

            <!-- Faceting defaults -->
            <str name="facet">on</str>
            <str name="facet.field">cat</str>
            <str name="facet.field">manu_exact</str>
            <str name="facet.mincount">1</str>

            <!-- Highlighting defaults -->
            <str name="hl">on</str>
            <str name="hl.fl">text features name</str>
            <str name="f.name.hl.fragsize">0</str>
            <str name="f.name.hl.alternateField">name</str>

            <!-- Spell checking defaults -->
            <str name="spellcheck">on</str>
            <str name="spellcheck.collate">true</str>
            <str name="spellcheck.onlyMorePopular">false</str>
            <str name="spellcheck.extendedResults">false</str>
            <str name="spellcheck.count">3</str>
        </lst>
        <arr name="last-components">
            <str>spellcheck</str>
        </arr>
        <!--
        <str name="url-scheme">httpx</str>
        -->
    </requestHandler>

    <requestHandler name="dismax" class="solr.SearchHandler">
        <lst name="defaults">
            <str name="defType">dismax</str>
            <str name="echoParams">explicit</str>
            <float name="tie">0.01</float>
            <str name="qf">course_id^30 code^10 classSuburb^5
                classPostcode^5 tutor^5 when^5
            </str>
            <str name="pf">course_id^30 code^10 classSuburb^5
                classPostcode^5 tutor^5 when^5
            </str>
            <str name="bf"></str>
            <str name="fl">course_id code classSuburb classPostcode
                tutor when
            </str>
            <str name="mm">1</str>
            <int name="ps">100</int>
            <str name="q.alt">*:*</str>
            <!-- example highlighter config, enable per-query with hl=true -->
            <str name="hl.fl">text features name</str>
            <!-- for this field, we want no fragmenting, just highlighting -->
            <str name="f.name.hl.fragsize">0</str>
            <!-- instructs Solr to return the field itself if no query terms are
                 found -->
            <str name="f.name.hl.alternateField">name</str>
            <str name="f.text.hl.fragmenter">regex</str> <!-- defined below -->
        </lst>
    </requestHandler>

    <requestHandler name="edismax" class="solr.SearchHandler">
        <lst name="defaults">
            <str name="defType">edismax</str>
            <str name="echoParams">explicit</str>
            <float name="tie">0.01</float>
            <str name="qf">course_id^30 code^10 classSuburb^5
                classPostcode^5 tutor^5 when^5
            </str>
            <str name="pf">course_id^30 code^10 classSuburb^5
                classPostcode^5 tutor^5 when^5
            </str>
            <str name="bf"></str>
            <str name="fl">course_id code classSuburb classPostcode
                tutor when
            </str>
            <str name="mm">1</str>
            <int name="ps">100</int>
            <str name="q.alt">*:*</str>
            <!-- example highlighter config, enable per-query with hl=true -->
        </lst>
    </requestHandler>

    <searchComponent name="spellcheck" class="solr.SpellCheckComponent">

        <str name="queryAnalyzerFieldType">textSpell</str>

        <lst name="spellchecker">
            <str name="name">default</str>
            <str name="field">name</str>
            <str name="spellcheckIndexDir">./spellchecker</str>
        </lst>
    </searchComponent>

    <requestHandler name="/spell" class="solr.SearchHandler" lazy="true">
        <lst name="defaults">
            <str name="spellcheck.onlyMorePopular">false</str>
            <str name="spellcheck.extendedResults">false</str>
            <str name="spellcheck.count">1</str>
        </lst>
        <arr name="last-components">
            <str>spellcheck</str>
        </arr>
    </requestHandler>

    <searchComponent name="tvComponent" class="org.apache.solr.handler.component.TermVectorComponent"/>

    <requestHandler name="tvrh" class="org.apache.solr.handler.component.SearchHandler">
        <lst name="defaults">
            <bool name="tv">true</bool>
        </lst>
        <arr name="last-components">
            <str>tvComponent</str>
        </arr>
    </requestHandler>

    <searchComponent
            name="clusteringComponent"
            enable="${solr.clustering.enabled:false}"
            class="org.apache.solr.handler.clustering.ClusteringComponent">
        <!-- Declare an engine -->
        <lst name="engine">
            <!-- The name, only one can be named "default" -->
            <str name="name">default</str>
            <str name="carrot.algorithm">org.carrot2.clustering.lingo.LingoClusteringAlgorithm</str>
            <str name="LingoClusteringAlgorithm.desiredClusterCountBase">20</str>
            <str name="MultilingualClustering.defaultLanguage">ENGLISH</str>
        </lst>
        <lst name="engine">
            <str name="name">stc</str>
            <str name="carrot.algorithm">org.carrot2.clustering.stc.STCClusteringAlgorithm</str>
        </lst>
    </searchComponent>
    <requestHandler name="/clustering"
                    enable="${solr.clustering.enabled:false}"
                    class="solr.SearchHandler">
        <lst name="defaults">
            <bool name="clustering">true</bool>
            <str name="clustering.engine">default</str>
            <bool name="clustering.results">true</bool>
            <!-- The title field -->
            <str name="carrot.title">name</str>
            <str name="carrot.url">id</str>
            <!-- The field to cluster on -->
            <str name="carrot.snippet">features</str>
            <!-- produce summaries -->
            <bool name="carrot.produceSummary">true</bool>
            <!-- the maximum number of labels per cluster -->
            <!--<int name="carrot.numDescriptions">5</int>-->
            <!-- produce sub clusters -->
            <bool name="carrot.outputSubClusters">false</bool>
        </lst>
        <arr name="last-components">
            <str>clusteringComponent</str>
        </arr>
    </requestHandler>

    <!-- Solr Cell: http://wiki.apache.org/solr/ExtractingRequestHandler -->
    <requestHandler name="/update/extract" class="org.apache.solr.handler.extraction.ExtractingRequestHandler"
                    startup="lazy">
        <lst name="defaults">
            <!-- All the main content goes into "text"... if you need to return
                 the extracted text or do highlighting, use a stored field. -->
            <str name="fmap.content">text</str>
            <str name="lowernames">true</str>
            <str name="uprefix">ignored_</str>

            <!-- capture link hrefs but ignore div attributes -->
            <str name="captureAttr">true</str>
            <str name="fmap.a">links</str>
            <str name="fmap.div">ignored_</str>
        </lst>
    </requestHandler>


    <!-- A component to return terms and document frequency of those terms. -->
    <searchComponent name="termsComponent" class="org.apache.solr.handler.component.TermsComponent"/>

    <requestHandler name="/terms" class="org.apache.solr.handler.component.SearchHandler">
        <lst name="defaults">
            <bool name="terms">true</bool>
        </lst>
        <arr name="components">
            <str>termsComponent</str>
        </arr>
    </requestHandler>

    <updateRequestProcessorChain name="composite-id">
        <processor class="solr.CloneFieldUpdateProcessorFactory">
            <str name="source">classId</str>
            <str name="source">siteKey</str>
            <str name="dest">id</str>
        </processor>
        <processor class="solr.ConcatFieldUpdateProcessorFactory">
            <str name="fieldName">id</str>
            <str name="delimiter">-</str>
        </processor>
        <processor class="solr.LogUpdateProcessorFactory" />
        <processor class="solr.RunUpdateProcessorFactory" />
    </updateRequestProcessorChain>

    <requestHandler name="/update" class="solr.UpdateRequestHandler">
        <lst name="defaults">
            <str name="update.chain">composite-id</str>
        </lst>
    </requestHandler>
    
    <requestHandler name="/update/javabin" class="solr.UpdateRequestHandler"/>
    <requestHandler name="/analysis/document" class="solr.DocumentAnalysisRequestHandler"/>
    <requestHandler name="/analysis/field" class="solr.FieldAnalysisRequestHandler"/>


    <!-- CSV update handler, loaded on demand -->
    <requestHandler name="/update/csv" class="solr.CSVRequestHandler" startup="lazy"/>

    <!-- JSON update handler, loaded on demand -->
    <requestHandler name="/update/json" class="solr.JsonUpdateRequestHandler" startup="lazy"/>

    <!-- ping/healthcheck -->
    <requestHandler name="/admin/ping" class="PingRequestHandler">
        <lst name="defaults">
            <str name="qt">standard</str>
            <str name="q">solrpingquery</str>
            <str name="echoParams">all</str>
        </lst>
    </requestHandler>

    <!-- Echo the request contents back to the client -->
    <requestHandler name="/debug/dump" class="solr.DumpRequestHandler">
        <lst name="defaults">
            <str name="echoParams">explicit</str> <!-- for all params (including the default etc) use: 'all' -->
            <str name="echoHandler">true</str>
        </lst>
    </requestHandler>

    <searchComponent class="solr.HighlightComponent" name="highlight">
        <highlighting>
            <!-- Configure the standard fragmenter -->
            <!-- This could most likely be commented out in the "default" case -->
            <fragmenter name="gap" class="org.apache.solr.highlight.GapFragmenter" default="true">
                <lst name="defaults">
                    <int name="hl.fragsize">100</int>
                </lst>
            </fragmenter>

            <!-- A regular-expression-based fragmenter (f.i., for sentence extraction) -->
            <fragmenter name="regex" class="org.apache.solr.highlight.RegexFragmenter">
                <lst name="defaults">
                    <!-- slightly smaller fragsizes work better because of slop -->
                    <int name="hl.fragsize">70</int>
                    <!-- allow 50% slop on fragment sizes -->
                    <float name="hl.regex.slop">0.5</float>
                    <!-- a basic sentence pattern -->
                    <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
                </lst>
            </fragmenter>

            <!-- Configure the standard formatter -->
            <formatter name="html" class="org.apache.solr.highlight.HtmlFormatter" default="true">
                <lst name="defaults">
                    <str name="hl.simple.pre"><![CDATA[<em>]]></str>
                    <str name="hl.simple.post"><![CDATA[</em>]]></str>
                </lst>
            </formatter>

            <!-- Configure the standard encoder -->
            <encoder name="html" class="org.apache.solr.highlight.HtmlEncoder" default="true"/>

            <!-- Configure the standard fragListBuilder -->
            <fragListBuilder name="simple" class="org.apache.solr.highlight.SimpleFragListBuilder" default="true"/>

            <!-- Configure the single fragListBuilder -->
            <fragListBuilder name="single" class="org.apache.solr.highlight.SingleFragListBuilder"/>

            <!-- default tag FragmentsBuilder -->
            <fragmentsBuilder name="default" class="org.apache.solr.highlight.ScoreOrderFragmentsBuilder"
                              default="true">
                <!--
                <lst name="defaults">
                  <str name="hl.multiValuedSeparatorChar">/</str>
                </lst>
                -->
            </fragmentsBuilder>

            <!-- multi-colored tag FragmentsBuilder -->
            <fragmentsBuilder name="colored" class="org.apache.solr.highlight.ScoreOrderFragmentsBuilder">
                <lst name="defaults">
                    <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
                    <str name="hl.tag.post"><![CDATA[</b>]]></str>
                </lst>
            </fragmentsBuilder>
        </highlighting>
    </searchComponent>

    <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
        <int name="xsltCacheLifetimeSeconds">5</int>
    </queryResponseWriter>

    <admin>
        <defaultQuery>*:*</defaultQuery>
    </admin>

</config>