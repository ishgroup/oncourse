apply plugin: 'java'
apply plugin: 'application'

buildscript {
    repositories {
        maven {
            url 'https://repo.ish.com.au/content/groups/public'
        }
    }

    dependencies {
        classpath('io.swagger:swagger-codegen:2.3.1')
    }
}

ext {
    swaggerResources = "${rootDir}/common/codegen/common/src/main/resources/htmlDocs"
    swaggerSchema = "${project.projectDir}/src/main/resources/${swaggerName}"
    swaggerOutputDir = "${project.projectDir}"
}

configurations {
    swagger
    doc
}

dependencies {
    testCompile 'org.apache.commons:commons-dbcp2:2.1.1'
    testCompile 'org.apache.commons:commons-pool2:2.4.2'
    testCompile project(':common:test-functions')
    // swagger project(':common:codegen:jaxrs')
}

targetCompatibility = '1.8'
sourceCompatibility = '1.8'

sourceSets {
    swagger {
        java.srcDir "${project.projectDir}/build/generated-sources"
    }
}

test {
    systemProperty "oncourse.jdbc.url", System.getProperty("oncourse.jdbc.url")
    systemProperty "oncourse.jdbc.user", System.getProperty("oncourse.jdbc.user")
    systemProperty "oncourse.jdbc.password", System.getProperty("oncourse.jdbc.password")
}

compileGroovy {
    groovyOptions.configurationScript = file("config.groovy")
}

processResources.doLast {
    file("${buildDir}/resources/VERSION").text = version ?: "SNAPSHOT"
}

// the following block isn't working for me when placed in the top level build.gradle
startScripts {
    unixStartScriptGenerator.template = resources.text.fromFile("${project.rootDir}/buildSrc/src/main/resources/applicationStartScript.sh")

}

distZip {
    applicationDistribution.from( "${buildDir}/resources/VERSION" ) {
        into('.')
    }
}

publishing {
// For deploying to our repo
    publications {
        executables(MavenPublication) {
            artifact(distZip) {
                classifier "executable"
                extension "zip"
            }
        }
        
        releases(MavenPublication) {
            artifact("${buildDir}/doc/doc.zip") {
                classifier "documentation"
                extension "zip"
            }
        }
    }
}

task swagger (type: JavaExec) {
    inputs.file swaggerSchema
    main = 'ish.oncourse.codegen.cxf.WillowJaxRsGenerator'
    classpath = configurations.swagger
    args  = [ servicesPackage, modelPackage, project.projectDir, swaggerSchema ]
}

import io.swagger.codegen.config.CodegenConfigurator
import io.swagger.codegen.DefaultGenerator

task swagger2 {
    inputs.file swaggerSchema
    outputs.dir "${project.projectDir}/build/generated-sources"
    doLast {
        def config = new CodegenConfigurator()
        config.setInputSpec(swaggerSchema)
        config.setOutputDir("${project.projectDir}/build/generated-sources")
        config.setLang('groovy')
        config.setAdditionalProperties([
                'invokerPackage': 'ish.oncourse.willow.editor.service',
                'modelPackage'  : 'ish.oncourse.willow.editor.model',
                'apiPackage'    : 'ish.oncourse.willow.editor.model.api',
                'supportingFiles': '', // skip scripts and maven files
                'dateLibrary'   : 'java8',
                'appVersion'    : project.version
        ])
        // config.setImportMappings([
        //         'Dog': 'io.swagger.petstore.client.model.Dog'
        // ])
        new DefaultGenerator().opts(config.toClientOptInput()).generate()
    }
}

compileJava {
    dependsOn swagger2
    source += sourceSets.swagger.java
}

clean.doFirst {
    delete("${project.projectDir}/build/generated-sources")
}

task docGenerate (type: JavaExec) {
    inputs.file "${project.projectDir}/src/main/resources/${swaggerName}"
    outputs.dir "${buildDir}/doc"

    classpath = configurations.swagger
    main = 'io.swagger.codegen.SwaggerCodegen'
    args  = [ 'generate',
              '-i', swaggerSchema,
              '-l', 'dynamic-html',
              '-t', "$swaggerResources",
              '-o', outputs.files.last()
            ]
}

task docCss (type: Copy, dependsOn: docGenerate) {
    from "${swaggerResources}"
    into "${buildDir}/doc/docs/assets/css"
}

task buildDoc (type: Zip, dependsOn: docCss) {
    from "${buildDir}/doc/docs"
    archiveName 'doc.zip'
    destinationDir file("${buildDir}/doc")
}
