<?xml version="1.0" encoding="UTF-8" ?>
<schema name="oncourse" version="1.2">
	<types>

		<fieldType name="location_rpt" class="solr.SpatialRecursivePrefixTreeFieldType" 
			spatialContextFactory="com.spatial4j.core.context.jts.JtsSpatialContextFactory" distErrPct="0.025" maxDistErr="0.000009" units="degrees"/>

		<fieldType name="string" class="solr.StrField"
			sortMissingLast="true" omitNorms="true" />

		<fieldType name="boolean" class="solr.BoolField"
			sortMissingLast="true" omitNorms="true" />
		<fieldtype name="binary" class="solr.BinaryField" />

		<fieldType name="int" class="solr.TrieIntField"
			precisionStep="0" omitNorms="true" positionIncrementGap="0" />
		<fieldType name="float" class="solr.TrieFloatField"
			precisionStep="0" omitNorms="true" positionIncrementGap="0" />
		<fieldType name="long" class="solr.TrieLongField"
			precisionStep="0" omitNorms="true" positionIncrementGap="0" />
		<fieldType name="double" class="solr.TrieDoubleField"
			precisionStep="0" omitNorms="true" positionIncrementGap="0" />

		<fieldType name="tdouble" class="solr.TrieDoubleField"
			precisionStep="8" omitNorms="true" positionIncrementGap="0" />

		<fieldType name="date" class="solr.TrieDateField" omitNorms="true"
			precisionStep="0" positionIncrementGap="0" />

		<fieldType name="sfloat" class="solr.SortableFloatField"
			sortMissingLast="true" omitNorms="true" />
		
		<fieldType name="exacttext" class="solr.StrField"
			sortMissingLast="true" omitNorms="true">
		</fieldType>
		
		<fieldType name="text" class="solr.TextField"
			positionIncrementGap="100">

			<analyzer type="index">
				<!-- Creates tokens of characters separated by splitting on whitespace -->
				<tokenizer class="solr.WhitespaceTokenizerFactory" />
				<!-- Discards common words -->
				<filter class="solr.StopFilterFactory" ignoreCase="true"
					words="stopwords.txt" enablePositionIncrements="true" />
				<!-- 
				Splits words into subwords and performs optional transformations on subword groups.
				
				split on intra-word delimiters (all non alpha-numeric characters).
				"Wi-Fi" -> "Wi", "Fi"
				
				leading and trailing intra-word delimiters on each subword are ignored
				"//hello-there, 'dude'" -> "hello", "there", "dude"
				
				splitOnCaseChange="1" causes lowercase => uppercase transitions to generate a new part [Solr 1.3]: 
				"PowerShot" => "Power" "Shot"
				
				stemEnglishPossessive="1" causes trailing "'s" to be removed for each subword.default is true ("1"); set to 0 to turn off 
				"Doug's" => "Doug"
				
				generateWordParts="1" causes parts of words to be generated: 
				"Power-Shot" => "Power" "Shot"
				
				generateNumberParts="1" causes number subwords to be generated:
				"500-42" => "500" "42"
				
				catenateWords="1" causes maximum runs of word parts to be catenated:
				"wi-fi" => "wifi"
				
				catenateNumbers="1" causes maximum runs of number parts to be catenated: default is 0 
				"500-42" => "50042"
				
				catenateAll="1" causes all subword parts to be catenated: default is 0 
				"wi-fi-4000" => "wifi4000"
				
				protected="protwords.txt" specifies a text file containing a list of words that should be protected and passed through unchanged.
				default is empty (no protected words) 
				
				types="wdfftypes.txt" allows customized tokenization for this filter. 
				The file should exist in the solr/conf directory, and entries are of the form (without quotes) "% => ALPHA" or "\u002C => DIGIT". 
				Allowable types are: LOWER, UPPER, ALPHA, DIGIT, ALPHANUM, SUBWORD_DELIM. [Solr3.1] 
				 -->
				<filter class="solr.WordDelimiterFilterFactory"
					generateWordParts="1" generateNumberParts="1" catenateWords="1"
					catenateNumbers="1" catenateAll="0" splitOnCaseChange="1" />
				<!-- 
				Lowercases the letters in each token. Leaves non-letter tokens alone.
				"I.B.M.", "Solr" ==> "i.b.m.", "solr".
				 -->
				<filter class="solr.LowerCaseFilterFactory" />
				
				<filter class="solr.HunspellStemFilterFactory" dictionary="../../dictionary/en_AU.dic" affix="../../dictionary/en_AU.aff" ignoreCase="true" />
				<!-- 
				Applies a regexp pattern to string in char stream, replacing match occurances with the specified replacement string. 
				Useless if we replace the syntax characters from the solr-query because nothing to replace
				 -->
				<!--charFilter class="solr.PatternReplaceCharFilterFactory" pattern="(\()" replacement="" replace="all"/-->
			</analyzer>

			<analyzer type="query">
				<tokenizer class="solr.WhitespaceTokenizerFactory" />
				<!-- 
				Matches strings of tokens and replaces them with other strings of tokens.
				
				The synonyms parameter names an external file defining the synonyms.
				
				If ignoreCase is true, matching will lowercase before checking equality.
				
				If expand is true, a synonym will be expanded to all equivalent synonyms. 
				If it is false, all equivalent synonyms will be reduced to the first in the list. 
				 -->
				<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"
					ignoreCase="true" expand="true" />
				<filter class="solr.StopFilterFactory" ignoreCase="true"
					words="stopwords.txt" enablePositionIncrements="true" />
				<filter class="solr.WordDelimiterFilterFactory"
					generateWordParts="1" generateNumberParts="1" catenateWords="0"
					catenateNumbers="0" catenateAll="0" splitOnCaseChange="1" />
				<filter class="solr.LowerCaseFilterFactory" />
				<filter class="solr.HunspellStemFilterFactory" dictionary="../../dictionary/en_AU.dic" affix="../../dictionary/en_AU.aff" ignoreCase="true" />
			</analyzer>
		</fieldType>


		<!-- A general unstemmed text field - good if one does not know the language 
			of the field -->
		<fieldType name="textgen" class="solr.TextField"
			positionIncrementGap="100">
			<analyzer type="index">
				<tokenizer class="solr.WhitespaceTokenizerFactory" />
				<!-- 
				Filters out any tokens which are at the same logical position in the tokenstream as a previous token with the same text. 
				This situation can arise from a number of situations depending on what the "up stream" token filters are - notably when stemming synonyms with similar roots. 
				It is usefull to remove the duplicates to prevent idf inflation at index time, or tf inflation (in a MultiPhraseQuery) at query time.
				 -->
				<filter class="solr.RemoveDuplicatesTokenFilterFactory" />
				<filter class="solr.StopFilterFactory" ignoreCase="true"
					words="stopwords.txt" enablePositionIncrements="true" />
				<filter class="solr.WordDelimiterFilterFactory"
					generateWordParts="1" generateNumberParts="1" catenateWords="1"
					catenateNumbers="1" catenateAll="0" splitOnCaseChange="0" />
				<filter class="solr.LowerCaseFilterFactory" />
				<!--filter class="solr.HunspellStemFilterFactory" dictionary="../../dictionary/en_AU.dic" affix="../../dictionary/en_AU.aff" 
					ignoreCase="true" /-->
			</analyzer>
			
			<analyzer type="query">
				<tokenizer class="solr.WhitespaceTokenizerFactory" />
				<filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt"
					ignoreCase="true" expand="true" />
				<filter class="solr.StopFilterFactory" ignoreCase="true"
					words="stopwords.txt" enablePositionIncrements="true" />
				<filter class="solr.WordDelimiterFilterFactory"
					generateWordParts="1" generateNumberParts="1" catenateWords="0"
					catenateNumbers="0" catenateAll="0" splitOnCaseChange="0" />
				<filter class="solr.LowerCaseFilterFactory" />
				<!--filter class="solr.HunspellStemFilterFactory" dictionary="../../dictionary/en_AU.dic" affix="../../dictionary/en_AU.aff" 
					ignoreCase="true" /-->
			</analyzer>
		</fieldType>
	</types>


	<fields>
		<field name="id" type="string" indexed="true" stored="true"
			required="true" />

		<field name="doctype" type="string" indexed="true" stored="true"
			required="true" />

		<field name="collegeId" type="int" indexed="true" stored="true" />

		<field name="name" type="textgen" indexed="true" stored="true"
			omitNorms="false"/>

		<field name="course_code" type="exacttext" indexed="true" stored="true"
			omitNorms="false"/>
			
		<field name="detail" type="text" indexed="true" stored="true"
			omitNorms="false"/>

		<field name="class_code" type="exacttext" indexed="true" stored="true"
			multiValued="true" omitNorms="false"/>

		<field name="tutor" type="text" indexed="true" stored="true"
			omitNorms="false" multiValued="true"/>

		<field name="when" type="text" indexed="true" stored="true"
			omitNorms="false" multiValued="true"/>

		<field name="startDate" type="date" indexed="true" stored="true"
			omitNorms="false" />

		<field name="end" type="date" indexed="true" stored="true"
			multiValued="true" omitNorms="false"/>

        <field name="class_start" type="date" indexed="true" stored="true"
               multiValued="true" omitNorms="false"/>

        <field name="course_loc" type="location_rpt" indexed="true" stored="true" multiValued="true" />
        
		<field name="course_suburb" type="textgen" indexed="true"
			omitNorms="false" stored="true" multiValued="true"/>

		<field name="course_postcode" type="string" indexed="true"
			omitNorms="false" stored="true" multiValued="true"/>

		<field name="price" type="sfloat" indexed="true" stored="true"
			multiValued="true" omitNorms="false"/>

		<field name="tagId" type="long" indexed="true" stored="true"
			multiValued="true" omitNorms="true" omitTermFreqAndPositions="true"/>

	</fields>

	<uniqueKey>id</uniqueKey>
	<defaultSearchField>name</defaultSearchField>
	<solrQueryParser defaultOperator="OR" />
</schema>
