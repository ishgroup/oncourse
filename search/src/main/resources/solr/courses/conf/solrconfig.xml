<?xml version="1.0" encoding="UTF-8" ?>
<config>
  <luceneMatchVersion>LUCENE_40</luceneMatchVersion>

	<lib dir="../../contrib/extraction/lib" regex=".*\.jar"/>
	<lib dir="../../dist/" regex="apache-solr-cell-\d.*\.jar" />
	
	<lib dir="../../contrib/clustering/lib/" regex=".*\.jar"/>
	<lib dir="../../dist/" regex="apache-solr-clustering-\d.*\.jar" />
	
	<lib dir="../../contrib/langid/lib/" regex=".*\.jar" />
	<lib dir="../../dist/" regex="apache-solr-langid-\d.*\.jar" />
	
	<lib dir="../../contrib/velocity/lib" regex=".*\.jar" />
	<lib dir="../../dist/" regex="apache-solr-velocity-\d.*\.jar" />

	<lib dir="/total/crap/dir/ignored" />  

  <dataDir>${SOLR_DATA}/courses</dataDir>
  <directoryFactory name="DirectoryFactory" class="${solr.directoryFactory:solr.StandardDirectoryFactory}"/>
	
	<indexConfig>
		<writeLockTimeout>1000</writeLockTimeout>
		<maxIndexingThreads>8</maxIndexingThreads>
		<useCompoundFile>false</useCompoundFile>
		<ramBufferSizeMB>32</ramBufferSizeMB>
		<maxBufferedDocs>1000</maxBufferedDocs>
		
		<mergePolicy class="org.apache.lucene.index.TieredMergePolicy">
			<int name="maxMergeAtOnce">10</int>
			<int name="segmentsPerTier">10</int>
		</mergePolicy>
		
		<mergeFactor>10</mergeFactor>
		
		<mergeScheduler class="org.apache.lucene.index.ConcurrentMergeScheduler"/>
		
		<lockType>simple</lockType>
		<unlockOnStartup>true</unlockOnStartup>
		
		<termIndexInterval>128</termIndexInterval>
		
		<reopenReaders>true</reopenReaders>
		
		<deletionPolicy class="solr.SolrDeletionPolicy">
		<!-- The number of commit points to be kept -->
		<str name="maxCommitsToKeep">1</str>
		<!-- The number of optimized commit points to be kept -->
		<str name="maxOptimizedCommitsToKeep">0</str>
		<!--
	          Delete all commit points once they have reached the given age.
	          Supports DateMathParser syntax e.g.
		-->
		<!--
		<str name="maxCommitAge">30MINUTES</str>
		<str name="maxCommitAge">1DAY</str>
		-->
	    </deletionPolicy>
	
		<!-- Lucene Infostream
		To aid in advanced debugging, Lucene provides an "InfoStream"
		of detailed information when indexing.

		Setting The value to true will instruct the underlying Lucene
		IndexWriter to write its debugging info the specified file
		-->
		<infoStream file="INFOSTREAM.txt">false</infoStream>
		
	    <!-- maxFieldLength was removed in 4.0. To get similar behavior, include a 
	         LimitTokenCountFilterFactory in your fieldType definition. E.g. 
	     <filter class="solr.LimitTokenCountFilterFactory" maxTokenCount="10000"/>
	    -->
	</indexConfig>
	
  <jmx />

<!-- The default high-performance update handler -->
	<updateHandler class="solr.DirectUpdateHandler2">

	<autoCommit> 
		<maxTime>15000</maxTime> 
		<openSearcher>false</openSearcher> 
	</autoCommit>

    <!-- softAutoCommit is like autoCommit except it causes a
         'soft' commit which only ensures that changes are visible
         but does not ensure that data is synced to disk.  This is
         faster and more near-realtime friendly than a hard commit.
      -->
     <!--
       <autoSoftCommit> 
         <maxTime>1000</maxTime> 
       </autoSoftCommit>
      -->
	</updateHandler>
	
	<query>
    <maxBooleanClauses>1024</maxBooleanClauses>
    <filterCache
      class="solr.FastLRUCache"
      size="512"
      initialSize="512"
      autowarmCount="0"/>
      
    <queryResultCache
      class="solr.LRUCache"
      size="512"
      initialSize="512"
      autowarmCount="0"/>

    <documentCache
      class="solr.LRUCache"
      size="512"
      initialSize="512"
      autowarmCount="0"/>

    <enableLazyFieldLoading>true</enableLazyFieldLoading>
    <queryResultWindowSize>20</queryResultWindowSize>
    <queryResultMaxDocsCached>200</queryResultMaxDocsCached>
    
    <listener event="newSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
      </arr>
    </listener>

    <listener event="firstSearcher" class="solr.QuerySenderListener">
      <arr name="queries">
        <lst> <str name="q">solr rocks</str><str name="start">0</str><str name="rows">10</str></lst>
        <lst><str name="q">static firstSearcher warming query from solrconfig.xml</str></lst>
      </arr>
    </listener>

    <useColdSearcher>false</useColdSearcher>
    <maxWarmingSearchers>2</maxWarmingSearchers>

  </query>

  <!-- 
    Let the dispatch filter handler /select?qt=XXX
    handleSelect=true will use consistent error handling for /select and /update
    handleSelect=false will use solr1.1 style error formatting
    -->
  <requestDispatcher handleSelect="true" >
    <!--Make sure your system has some authentication before enabling remote streaming!  -->
    <requestParsers enableRemoteStreaming="true" multipartUploadLimitInKB="2048000" />

    <!-- Set HTTP caching related parameters (for proxy caches and clients).
          
         To get the behaviour of Solr 1.2 (ie: no caching related headers)
         use the never304="true" option and do not specify a value for
         <cacheControl>
    -->
    <!-- <httpCaching never304="true"> -->
    <httpCaching lastModifiedFrom="openTime"
                 etagSeed="Solr">
       <!-- lastModFrom="openTime" is the default, the Last-Modified value
            (and validation against If-Modified-Since requests) will all be
            relative to when the current Searcher was opened.
            You can change it to lastModFrom="dirLastMod" if you want the
            value to exactly corrispond to when the physical index was last
            modified.

            etagSeed="..." is an option you can change to force the ETag
            header (and validation against If-None-Match requests) to be
            differnet even if the index has not changed (ie: when making
            significant changes to your config file)

            lastModifiedFrom and etagSeed are both ignored if you use the
            never304="true" option.
       -->
       <!-- If you include a <cacheControl> directive, it will be used to
            generate a Cache-Control header, as well as an Expires header
            if the value contains "max-age="

            By default, no Cache-Control header is generated.

            You can use the <cacheControl> option even if you have set
            never304="true"
       -->
       <!-- <cacheControl>max-age=30, public</cacheControl> -->
    </httpCaching>
  </requestDispatcher>


  <!-- requestHandler plugins... incoming queries will be dispatched to the
     correct handler based on the path or the qt (query type) param.
     Names starting with a '/' are accessed with the a path equal to the 
     registered name.  Names without a leading '/' are accessed with:
      http://host/app/select?qt=name
     If no qt is defined, the requestHandler that declares default="true"
     will be used.
  -->
  <requestHandler name="standard" class="solr.SearchHandler" default="true">
    <!-- default values for query parameters -->
     <lst name="defaults">
       <str name="echoParams">explicit</str>
       <!--
       <int name="rows">10</int>
       <str name="fl">*</str>
       <str name="version">2.1</str>
        -->
     </lst>
     <!-- not included by default -->
     <!-- arr name="last-components">
       <str>pivot</str> 
     </arr-->
  </requestHandler>
  
  <!-- 
  -->
  <requestHandler name="/browse" class="solr.SearchHandler">
     <lst name="defaults">

       <!-- VelocityResponseWriter settings -->
       <str name="wt">velocity</str>
       <str name="v.template">browse</str>
       <str name="v.layout">layout</str>
       <str name="title">Solritas</str>

       <!-- Query settings -->
       <str name="defType">edismax</str>
       <str name="qf">name^20 course_code^30 class_code^10 suburb^5 postcode^5 tutor^5 when^5 detail^1</str>
       <str name="q.alt">*:*</str>
       <str name="rows">10</str>
       <str name="fl">*,score</str>

       <!-- Faceting defaults -->
       <str name="facet">on</str>
       <str name="facet.field">cat</str>
       <str name="facet.field">manu_exact</str>
       <str name="facet.mincount">1</str>

       <!-- Highlighting defaults -->
       <str name="hl">on</str>
       <str name="hl.fl">text features name</str>
       <str name="f.name.hl.fragsize">0</str>
       <str name="f.name.hl.alternateField">name</str>

       <!-- Spell checking defaults -->
       <str name="spellcheck">on</str>
       <str name="spellcheck.collate">true</str>
       <str name="spellcheck.onlyMorePopular">false</str>
       <str name="spellcheck.extendedResults">false</str>
       <str name="spellcheck.count">3</str>
     </lst>
     <arr name="last-components">
       <str>spellcheck</str>
     </arr>
     <!--
     <str name="url-scheme">httpx</str>
     -->
  </requestHandler>
  
  <requestHandler name="dismax" class="solr.SearchHandler" >
    <lst name="defaults">
     <str name="defType">dismax</str>
     <str name="echoParams">explicit</str>
     <float name="tie">0.01</float>
     <str name="qf">name^20 course_code^30 class_code^10 suburb^5
				postcode^5 tutor^5 when^5 detail^1</str>
	 <str name="pf">name^20 course_code^30 class_code^10 suburb^5
				postcode^5 tutor^5 when^5 detail^1</str>
	<str name="bf"></str>
	<str name="fl">name course_code class_code suburb postcode
				tutor when detail</str>
     <str name="mm">1</str>
     <int name="ps">100</int>
     <str name="q.alt">*:*</str>
     <!-- example highlighter config, enable per-query with hl=true -->
     <str name="hl.fl">text features name</str>
     <!-- for this field, we want no fragmenting, just highlighting -->
     <str name="f.name.hl.fragsize">0</str>
     <!-- instructs Solr to return the field itself if no query terms are
          found -->
     <str name="f.name.hl.alternateField">name</str>
     <str name="f.text.hl.fragmenter">regex</str> <!-- defined below -->
    </lst>
  </requestHandler>
  
  <requestHandler name="edismax" class="solr.SearchHandler" >
    <lst name="defaults">
     <str name="defType">edismax</str>
     <str name="echoParams">explicit</str>
     <float name="tie">0.01</float>
     <str name="qf">name^20 course_code^30 class_code^10 suburb^5
				postcode^5 tutor^5 when^5 detail^1</str>
	 <str name="pf">name^20 course_code^30 class_code^10 suburb^5
				postcode^5 tutor^5 when^5 detail^1</str>
	<str name="bf"></str>
	<str name="fl">name course_code class_code suburb postcode
				tutor when detail</str>
     <str name="mm">1</str>
     <int name="ps">100</int>
     <str name="q.alt">*:*</str>
     <!-- example highlighter config, enable per-query with hl=true -->
     <str name="hl.fl">text features name</str>
     <!-- for this field, we want no fragmenting, just highlighting -->
     <str name="f.name.hl.fragsize">0</str>
     <!-- instructs Solr to return the field itself if no query terms are
          found -->
     <str name="f.name.hl.alternateField">name</str>
     <str name="f.text.hl.fragmenter">regex</str> <!-- defined below -->
    </lst>
  </requestHandler>

  <!-- Note how you can register the same handler multiple times with
       different names (and different init parameters)
    -->
  <requestHandler name="partitioned" class="solr.SearchHandler" >
    <lst name="defaults">
     <str name="defType">edismax</str>
     <str name="echoParams">explicit</str>
     <str name="qf">text^0.5 features^1.0 name^1.2 sku^1.5 id^10.0</str>
     <str name="mm">2&lt;-1 5&lt;-2 6&lt;90%</str>
     <!-- This is an example of using Date Math to specify a constantly
          moving date range in a config...
       -->
     <str name="bq">incubationdate_dt:[* TO NOW/DAY-1MONTH]^2.2</str>
    </lst>
    <lst name="appends">
      <str name="fq">inStock:true</str>
    </lst>
    <lst name="invariants">
      <str name="facet.field">cat</str>
      <str name="facet.field">manu_exact</str>
      <str name="facet.query">price:[* TO 500]</str>
      <str name="facet.query">price:[500 TO *]</str>
    </lst>
  </requestHandler>

  <searchComponent name="spellcheck" class="solr.SpellCheckComponent">

    <str name="queryAnalyzerFieldType">textSpell</str>

    <lst name="spellchecker">
      <str name="name">default</str>
      <str name="field">name</str>
      <str name="spellcheckIndexDir">./spellchecker</str>
    </lst>
  </searchComponent>

  <requestHandler name="/spell" class="solr.SearchHandler" lazy="true">
    <lst name="defaults">
      <str name="spellcheck.onlyMorePopular">false</str>
      <str name="spellcheck.extendedResults">false</str>
      <str name="spellcheck.count">1</str>
    </lst>
    <arr name="last-components">
      <str>spellcheck</str>
    </arr>
  </requestHandler>

  <searchComponent name="tvComponent" class="org.apache.solr.handler.component.TermVectorComponent"/>
  
  <requestHandler name="tvrh" class="org.apache.solr.handler.component.SearchHandler">
    <lst name="defaults">
      <bool name="tv">true</bool>
    </lst>
    <arr name="last-components">
      <str>tvComponent</str>
    </arr>
  </requestHandler>

  <searchComponent
    name="clusteringComponent"
    enable="${solr.clustering.enabled:false}"
    class="org.apache.solr.handler.clustering.ClusteringComponent" >
    <!-- Declare an engine -->
    <lst name="engine">
      <!-- The name, only one can be named "default" -->
      <str name="name">default</str>
      <str name="carrot.algorithm">org.carrot2.clustering.lingo.LingoClusteringAlgorithm</str>
      <str name="LingoClusteringAlgorithm.desiredClusterCountBase">20</str>
      <str name="MultilingualClustering.defaultLanguage">ENGLISH</str>
    </lst>
    <lst name="engine">
      <str name="name">stc</str>
      <str name="carrot.algorithm">org.carrot2.clustering.stc.STCClusteringAlgorithm</str>
    </lst>
  </searchComponent>
  <requestHandler name="/clustering"
                  enable="${solr.clustering.enabled:false}"
                  class="solr.SearchHandler">
     <lst name="defaults">
       <bool name="clustering">true</bool>
       <str name="clustering.engine">default</str>
       <bool name="clustering.results">true</bool>
       <!-- The title field -->
       <str name="carrot.title">name</str>
       <str name="carrot.url">id</str>
       <!-- The field to cluster on -->
       <str name="carrot.snippet">features</str>
       <!-- produce summaries -->
       <bool name="carrot.produceSummary">true</bool>
       <!-- the maximum number of labels per cluster -->
       <!--<int name="carrot.numDescriptions">5</int>-->
       <!-- produce sub clusters -->
       <bool name="carrot.outputSubClusters">false</bool>
    </lst>     
    <arr name="last-components">
      <str>clusteringComponent</str>
    </arr>
  </requestHandler>
  
  <!-- Solr Cell: http://wiki.apache.org/solr/ExtractingRequestHandler -->
  <requestHandler name="/update/extract" class="org.apache.solr.handler.extraction.ExtractingRequestHandler" startup="lazy">
    <lst name="defaults">
      <!-- All the main content goes into "text"... if you need to return
           the extracted text or do highlighting, use a stored field. -->
      <str name="fmap.content">text</str>
      <str name="lowernames">true</str>
      <str name="uprefix">ignored_</str>

      <!-- capture link hrefs but ignore div attributes -->
      <str name="captureAttr">true</str>
      <str name="fmap.a">links</str>
      <str name="fmap.div">ignored_</str>
    </lst>
  </requestHandler>


  <!-- A component to return terms and document frequency of those terms. -->
  <searchComponent name="termsComponent" class="org.apache.solr.handler.component.TermsComponent"/>

  <requestHandler name="/terms" class="org.apache.solr.handler.component.SearchHandler">
     <lst name="defaults">
      <bool name="terms">true</bool>
    </lst>     
    <arr name="components">
      <str>termsComponent</str>
    </arr>
  </requestHandler>


  <!-- a search component that enables you to configure the top results for
       a given query regardless of the normal lucene scoring.-->
  <searchComponent name="elevator" class="solr.QueryElevationComponent" >
    <!-- pick a fieldType to analyze queries -->
    <str name="queryFieldType">string</str>
    <str name="config-file">elevate.xml</str>
  </searchComponent>

  <!-- a request handler utilizing the elevator component -->
  <requestHandler name="/elevate" class="solr.SearchHandler" startup="lazy">
    <lst name="defaults">
      <str name="echoParams">explicit</str>
    </lst>
    <arr name="last-components">
      <str>elevator</str>
    </arr>
  </requestHandler>
  
  <requestHandler name="/update" class="solr.UpdateRequestHandler" />
  <requestHandler name="/update/javabin" class="solr.UpdateRequestHandler" />
  <requestHandler name="/analysis/document" class="solr.DocumentAnalysisRequestHandler" />
  <requestHandler name="/analysis/field" class="solr.FieldAnalysisRequestHandler" />


  <!-- CSV update handler, loaded on demand -->
  <requestHandler name="/update/csv" class="solr.CSVRequestHandler" startup="lazy" />

  <!-- JSON update handler, loaded on demand -->
  <requestHandler name="/update/json" class="solr.JsonUpdateRequestHandler" startup="lazy" />
  <requestHandler name="/admin/" class="org.apache.solr.handler.admin.AdminHandlers" />
  
  <requestHandler name="/dataimport"
		class="org.apache.solr.handler.dataimport.DataImportHandler">
		<lst name="defaults">
			<str name="config">oncourse-jdbc.xml</str>
		</lst>
  </requestHandler>

  <!-- ping/healthcheck -->
  <requestHandler name="/admin/ping" class="PingRequestHandler">
    <lst name="defaults">
      <str name="qt">standard</str>
      <str name="q">solrpingquery</str>
      <str name="echoParams">all</str>
    </lst>
  </requestHandler>

  <!-- Echo the request contents back to the client -->
  <requestHandler name="/debug/dump" class="solr.DumpRequestHandler" >
    <lst name="defaults">
     <str name="echoParams">explicit</str> <!-- for all params (including the default etc) use: 'all' -->
     <str name="echoHandler">true</str>
    </lst>
  </requestHandler>
  
  <requestHandler name="/replication" class="solr.ReplicationHandler" >
    <lst name="master">
      <str name="enable">${solr.master.enable:false}</str>
      <str name="replicateAfter">startup</str>
      <str name="replicateAfter">commit</str>
      <str name="confFiles"></str>
	  <str name="maxNumberOfBackups">1</str> 
    </lst>
    <lst name="slave">
      <str name="enable">${solr.slave.enable:false}</str>
      <str name="masterUrl">http://${solr.master.url}/${solr.core.name}/replication</str>
      <str name="pollInterval">${solr.poll}</str>
    </lst>
  </requestHandler>
  
  <searchComponent class="solr.HighlightComponent" name="highlight">
    <highlighting>
      <!-- Configure the standard fragmenter -->
      <!-- This could most likely be commented out in the "default" case -->
      <fragmenter name="gap" class="org.apache.solr.highlight.GapFragmenter" default="true">
        <lst name="defaults">
          <int name="hl.fragsize">100</int>
        </lst>
      </fragmenter>

      <!-- A regular-expression-based fragmenter (f.i., for sentence extraction) -->
      <fragmenter name="regex" class="org.apache.solr.highlight.RegexFragmenter">
        <lst name="defaults">
          <!-- slightly smaller fragsizes work better because of slop -->
          <int name="hl.fragsize">70</int>
          <!-- allow 50% slop on fragment sizes -->
          <float name="hl.regex.slop">0.5</float>
          <!-- a basic sentence pattern -->
          <str name="hl.regex.pattern">[-\w ,/\n\&quot;&apos;]{20,200}</str>
        </lst>
      </fragmenter>

      <!-- Configure the standard formatter -->
      <formatter name="html" class="org.apache.solr.highlight.HtmlFormatter" default="true">
        <lst name="defaults">
          <str name="hl.simple.pre"><![CDATA[<em>]]></str>
          <str name="hl.simple.post"><![CDATA[</em>]]></str>
        </lst>
      </formatter>

      <!-- Configure the standard encoder -->
      <encoder name="html" class="org.apache.solr.highlight.HtmlEncoder" default="true"/>

      <!-- Configure the standard fragListBuilder -->
      <fragListBuilder name="simple" class="org.apache.solr.highlight.SimpleFragListBuilder" default="true"/>

      <!-- Configure the single fragListBuilder -->
      <fragListBuilder name="single" class="org.apache.solr.highlight.SingleFragListBuilder"/>

      <!-- default tag FragmentsBuilder -->
      <fragmentsBuilder name="default" class="org.apache.solr.highlight.ScoreOrderFragmentsBuilder" default="true">
        <!-- 
        <lst name="defaults">
          <str name="hl.multiValuedSeparatorChar">/</str>
        </lst>
        -->
      </fragmentsBuilder>

      <!-- multi-colored tag FragmentsBuilder -->
      <fragmentsBuilder name="colored" class="org.apache.solr.highlight.ScoreOrderFragmentsBuilder">
        <lst name="defaults">
          <str name="hl.tag.pre"><![CDATA[
               <b style="background:yellow">,<b style="background:lawgreen">,
               <b style="background:aquamarine">,<b style="background:magenta">,
               <b style="background:palegreen">,<b style="background:coral">,
               <b style="background:wheat">,<b style="background:khaki">,
               <b style="background:lime">,<b style="background:deepskyblue">]]></str>
          <str name="hl.tag.post"><![CDATA[</b>]]></str>
        </lst>
      </fragmentsBuilder>
    </highlighting>
  </searchComponent>
  
  <queryResponseWriter name="xslt" class="solr.XSLTResponseWriter">
    <int name="xsltCacheLifetimeSeconds">5</int>
  </queryResponseWriter>

  <!-- an alternative query parser to geofilt() (notably allows a specific lat-lon box) -->
  <!--queryParser name="gh_geofilt" class="solr2155.solr.search.SpatialGeoHashFilterQParser$Plugin" /-->
  <!-- overwrite built-in geodist() with our own modified one -->
  <!--valueSourceParser name="geodist" class="solr2155.solr.search.function.distance.HaversineConstFunction$HaversineValueSourceParser" /-->

  <admin>
    <defaultQuery>*:*</defaultQuery>
  </admin>
 
</config>