/*
 * Copyright ish group pty ltd 2020.
 *
 * This program is free software: you can redistribute it and/or modify it under the terms of the
 * GNU Affero General Public License version 3 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero General Public License for more details.
 */

package ish.oncourse.server.api.v1.service.impl

import com.google.inject.Inject
import groovy.transform.CompileStatic
import ish.common.types.PaymentStatus
import ish.common.types.PaymentType
import ish.math.Money
import ish.oncourse.cayenne.PaymentInterface
import ish.oncourse.common.BankingType
import static ish.oncourse.common.BankingType.AUTO_AMEX
import static ish.oncourse.common.BankingType.AUTO_MCVISA
import static ish.oncourse.common.BankingType.AUTO_OTHER
import static ish.oncourse.common.BankingType.GATEWAY
import static ish.oncourse.common.BankingType.MANUAL
import ish.oncourse.server.ICayenneService
import static ish.oncourse.server.api.function.CayenneFunctions.deleteRecord
import static ish.oncourse.server.api.function.CayenneFunctions.getRecordById
import static ish.oncourse.server.api.function.EntityFunctions.checkForBadRequest
import static ish.oncourse.server.api.function.EntityFunctions.validateEntityExistence
import static ish.oncourse.server.api.function.EntityFunctions.validateIdParam
import ish.oncourse.server.api.service.BankingService
import static ish.oncourse.server.api.v1.function.BankingFunctions.IN_PREFIX
import static ish.oncourse.server.api.v1.function.BankingFunctions.OUT_PREFIX
import static ish.oncourse.server.api.v1.function.BankingFunctions.asModelPaymentInterface
import static ish.oncourse.server.api.v1.function.BankingFunctions.toRestBanking
import ish.oncourse.server.api.v1.model.BankingDTO
import ish.oncourse.server.api.v1.model.PaymentDTO
import ish.oncourse.server.api.v1.model.ValidationErrorDTO
import ish.oncourse.server.api.v1.service.BankingApi
import ish.oncourse.server.cayenne.Account
import ish.oncourse.server.cayenne.Banking
import ish.oncourse.server.cayenne.PaymentIn
import ish.oncourse.server.cayenne.PaymentMethod
import ish.oncourse.server.cayenne.PaymentOut
import ish.oncourse.server.cayenne.Site
import ish.oncourse.server.services.TransactionLockedService
import ish.oncourse.server.users.SystemUserService
import org.apache.cayenne.ObjectContext
import static org.apache.cayenne.query.ObjectSelect.query
import org.apache.cayenne.query.SelectById

import javax.ws.rs.ServerErrorException
import javax.ws.rs.core.Response
import java.time.LocalDate

@CompileStatic
class BankingApiImpl implements BankingApi {

	private static String ERROR_DELETE_GATEWAY = "You may not delete banking which was automatically generated by the payment gateway."
	private static String ERROR_TRANSACTION_LOCKED = "You may not delete banking which has settlement date before 'Transaction Locked' date (%s)."
	private static String ERROR_TRANSACTION_LOCKED_SETTLEMENT_DATE = "You may not change settlement date for banking which has settlement date before 'Transaction Locked' date (%s)."
	private static String ERROR_TRANSACTION_LOCKED_PAYMENT_DELETE = "You may not delete payment from banking which has settlement date before 'Transaction Locked' date (%s)."
	private static String ERROR_SETTLEMENT_DATE = "You must choose the settlement date after 'Transaction Locked' date (%s)."
	private static String ERROR_AUTOMATICALLY_BANKED_PAYMENT = "Can not process automatically banked payments for manually created banking."
	private static String ERROR_NOT_SINGLE_ACCOUNT = "Account must be single for all payments."
	private static String ERROR_SETTLEMENT_DATE_IS_NULL = "Settlement Date is required."
	private static String ERROR_NO_PAYMENTS_SELECTED = "No payments selected for deposit banking."
	private static String ERROR_PAYMENT_BANKING_IS_SET = "Can not set banking for some payment(s) (already set)."
	private static String ERROR_PAYMENT_IS_NOT_RECONCILABLE = "You may not change reconcilable status for not reconcilable payment(s)."
	private static String ERROR_DATE_BANKED_AFTER_DATE_PAID = "Date banked must be after or equal to date paid."

	@Inject
	ICayenneService cayenneService

	@Inject
	TransactionLockedService transactionLockedService

	@Inject
	BankingService bankingService

	@Inject
	private SystemUserService systemUserService

	@Override
	void create(BankingDTO mb) {

		checkForBadRequest(validateSettlementDateIsNotNull(mb))
		checkForBadRequest(validatePaymentListIsNotEmpty(mb))
		checkForBadRequest(validateIsSettlementDateAfterLockedDate(mb.settlementDate, transactionLockedService.transactionLocked, ERROR_SETTLEMENT_DATE))

		ObjectContext context = cayenneService.newContext
		List<PaymentIn> paymentsIn = []
		List<PaymentOut> paymentsOut = []

		List<Long> inIds = mb.payments.findAll {it.id.startsWith(IN_PREFIX)}.collect {it.paymentId}
		List<Long> outIds = mb.payments.findAll {it.id.startsWith(OUT_PREFIX)}.collect {it.paymentId}

		if (!inIds.empty) {
			paymentsIn = query(PaymentIn).where(PaymentIn.ID.in(inIds)).select(context)
		}
		if (!outIds.empty) {
			paymentsOut = query(PaymentOut).where(PaymentOut.ID.in(outIds)).select(context)
		}

		List<PaymentInterface> paymentsToAdd = new ArrayList<PaymentInterface>()
		paymentsToAdd.addAll(paymentsIn)
		paymentsToAdd.addAll(paymentsOut)

		Account account = paymentsIn.size() > 0 ? paymentsIn.get(0).accountIn : paymentsOut.get(0).accountOut
		Site site = getRecordById(context, Site, mb.administrationCenterId)
		Long accountId = account.id

		paymentsIn.each { it ->
			checkForBadRequest(validateSameAccount(it, accountId))
			checkForBadRequest(validatePaymentIsNotBanked(it))
			checkForBadRequest(validateDateBankedAndPaymentDate(mb.settlementDate, it.paymentDate))
		}
		paymentsOut.each { it ->
			checkForBadRequest(validateSameAccount(it, accountId))
			checkForBadRequest(validatePaymentIsNotBanked(it))
			checkForBadRequest(validateDateBankedAndPaymentDate(mb.settlementDate, it.paymentDate))
		}

		Banking newBanking = null


		paymentsToAdd.each { payment ->
			if (payment.paymentMethod.bankedAutomatically) {
				bankingService.assignBanking(payment, mb.settlementDate, null)
			}
			else {
				if (newBanking == null) {
					newBanking = bankingService.createBanking(MANUAL, account, mb.settlementDate, site, context)
				}
				payment.banking = newBanking
			}
		}

		context.commitChanges()
	}

	@Override
	BankingDTO get(Long id) {
		toRestBanking(getRecordById(cayenneService.newContext, Banking, id))
	}

	@Override
	List<PaymentDTO> getDepositPayments(Long accountId, Long siteId) {

		ObjectContext context = cayenneService.newContext
		Site site = getRecordById(context, Site, siteId)

		List<PaymentIn> paymentIns = query(PaymentIn.class)
				.where(PaymentIn.ACCOUNT_IN.dot(Account.ID).eq(accountId.toLong()))
				.and(PaymentIn.BANKING.isNull())
				.and(PaymentIn.STATUS.eq(PaymentStatus.SUCCESS))
				.and(PaymentIn.AMOUNT.nin(Money.ZERO))
				.and(PaymentIn.ADMINISTRATION_CENTRE.eq(site).orExp(PaymentIn.ADMINISTRATION_CENTRE.isNull()))
				.and(PaymentIn.PAYMENT_METHOD.dot(PaymentMethod.TYPE).nin(PaymentType.VOUCHER))
				.select(cayenneService.newContext)

		List<PaymentOut> paymentOuts = query(PaymentOut.class)
				.where(PaymentOut.ACCOUNT_OUT.dot(Account.ID).eq(accountId.toLong()))
				.and(PaymentOut.BANKING.isNull())
				.and(PaymentOut.STATUS.eq(PaymentStatus.SUCCESS))
				.and(PaymentOut.AMOUNT.nin(Money.ZERO))
				.and(PaymentOut.ADMINISTRATION_CENTRE.eq(site).orExp(PaymentOut.ADMINISTRATION_CENTRE.isNull()))
				.select(cayenneService.newContext)

		return paymentIns.collect{ asModelPaymentInterface(it) } + paymentOuts.collect{ asModelPaymentInterface(it) }
	}

	@Override
	void reconcile(List<Long> ids) {
		ObjectContext context = cayenneService.newContext
		ids.each { id ->
			Banking banking = getRecordById(context, Banking, id)
			checkForBadRequest(validateEntityExistence(id, banking))
		}
		try {
			ids.collect { SelectById.query(Banking, it).selectOne(context) }.each { b ->
				b.paymentsIn.findAll { it.paymentMethod.reconcilable }.each { it.reconciled = true }
				b.paymentsOut.findAll { it.paymentMethod.reconcilable }.each { it.reconciled = true }
			}
			context.commitChanges()
		}
		catch (Exception e) {
			throw new ServerErrorException("Unexpected error during reconcile: ${e.message}", Response.Status.INTERNAL_SERVER_ERROR)
		}
	}

	@Override
	void remove(Long id) {
		checkForBadRequest(validateIdParam(id))

		ObjectContext context = cayenneService.newContext
		Banking banking = getRecordById(context, Banking, id)

		checkForBadRequest(validateEntityExistence(id, banking))
		checkForBadRequest(validateIsSettlementDateAfterLockedDate(banking.settlementDate, transactionLockedService.transactionLocked, ERROR_TRANSACTION_LOCKED))
		checkForBadRequest(validateNotGateway(banking))

		banking.paymentsIn.stream().filter{ it.paymentMethod.reconcilable }.forEach{ it.reconciled = false }
		banking.paymentsOut.stream().filter{ it.paymentMethod.reconcilable }.forEach{ it.reconciled = false }

		deleteRecord(context, banking)
	}

	@Override
	void update(Long id, BankingDTO mb) {
		ObjectContext context = cayenneService.newContext
		Banking cb = getRecordById(context, Banking, id)
		LocalDate transactionLockedDate = transactionLockedService.transactionLocked

		checkForBadRequest(validateEntityExistence(id, cb))
		checkForBadRequest(validateSettlementDateIsNotNull(mb))

		if (mb.payments.size() == 0) {
			checkForBadRequest(validateIsSettlementDateAfterLockedDate(cb.settlementDate, transactionLockedDate, ERROR_TRANSACTION_LOCKED))

			new ArrayList<PaymentIn>(cb.paymentsIn).stream().filter{ it.paymentMethod.reconcilable }.forEach{
				removePaymentFromBanking(it)
			}

			new ArrayList<PaymentOut>(cb.paymentsOut).stream().filter{ it.paymentMethod.reconcilable }.forEach{
				removePaymentFromBanking(it)
			}

			context.deleteObject(cb)

		} else {
			if (mb.getSettlementDate().compareTo(cb.settlementDate) != 0) {
				checkForBadRequest(validateIsSettlementDateAfterLockedDate(cb.settlementDate, transactionLockedDate, ERROR_TRANSACTION_LOCKED_SETTLEMENT_DATE))
				checkForBadRequest(validateIsSettlementDateAfterLockedDate(mb.settlementDate, transactionLockedDate, ERROR_SETTLEMENT_DATE))
				cb.settlementDate = mb.settlementDate
			}

			ArrayList<PaymentIn> paymentsIn = new ArrayList<PaymentIn>(cb.paymentsIn)
			ArrayList<PaymentOut> paymentsOut = new ArrayList<PaymentOut>(cb.paymentsOut)

			if (cb.settlementDate.compareTo(transactionLockedDate) <= 0) {
				checkForBadRequest(validateRemovePaymentsFromLockedBanking(mb.payments.size(), paymentsIn.size() + paymentsOut.size(), transactionLockedDate, ERROR_TRANSACTION_LOCKED_PAYMENT_DELETE))
			}

			paymentsIn.each { paymentIn ->
				PaymentDTO payment = mb.payments.findAll {it.id.startsWith(IN_PREFIX)}.find { it.paymentId == paymentIn.id }
				checkForBadRequest(validatePaymentIsNotReconcilable(payment, paymentIn))
				updatePaymentInterface(paymentIn, payment)
			}
			paymentsOut.each { paymentOut ->
				PaymentDTO payment = mb.payments.findAll {it.id.startsWith(OUT_PREFIX)}.find { it.paymentId == paymentOut.id }
				checkForBadRequest(validatePaymentIsNotReconcilable(payment, paymentOut))
				updatePaymentInterface(paymentOut, payment)
			}

		}

		try {
			context.commitChanges()
		} catch (Exception e) {
			throw new ServerErrorException("Unexpected error during applying changes: ${e.message}", Response.Status.INTERNAL_SERVER_ERROR)
		}
	}

	private static ValidationErrorDTO validatePaymentIsNotReconcilable(PaymentDTO payment, PaymentInterface paymentInterface) {
		if (!paymentInterface.paymentMethod.reconcilable && payment.reconciled != paymentInterface.reconciled) {
			return new ValidationErrorDTO("---", "payments", ERROR_PAYMENT_IS_NOT_RECONCILABLE)
		}
		return null
	}

	private static ValidationErrorDTO validateRemovePaymentsFromLockedBanking(int cayennePaymentsSize, int modelPaymentsSize, LocalDate lockedDate, String message) {
		if (cayennePaymentsSize != modelPaymentsSize) {
			return new ValidationErrorDTO("---", "payments", String.format(message, lockedDate.toString()))
		}
		return null
	}

	private static ValidationErrorDTO validatePaymentIsNotBanked(PaymentInterface paymentInterface) {
		if (paymentInterface.banking != null) {
			return new ValidationErrorDTO("---", "payments", ERROR_PAYMENT_BANKING_IS_SET)
		}
		return null
	}

	private static ValidationErrorDTO validateSameAccount(PaymentInterface paymentInterface, Long accountId) {
		Long paymentAccountId = paymentInterface instanceof PaymentIn ? paymentInterface.accountIn.id : (paymentInterface as PaymentOut).accountOut.id
		if (paymentAccountId != accountId) {
			return new ValidationErrorDTO("---", "payments", ERROR_NOT_SINGLE_ACCOUNT)
		}
		return null
	}

	private static ValidationErrorDTO validateSettlementDateIsNotNull(BankingDTO banking) {
		if (banking.settlementDate == null) {
			return new ValidationErrorDTO("---", "settlementDate", ERROR_SETTLEMENT_DATE_IS_NULL)
		}
		return null
	}

	private  ValidationErrorDTO validateAdminSite(BankingDTO banking) {
		if (banking.administrationCenterId == null) {
			return new ValidationErrorDTO(null,"administrationCentreId", "Administration centre is required")
		}

		Site adminCentr = getRecordById(cayenneService.newContext, Site, banking.administrationCenterId)
		if (!adminCentr) {
			return new ValidationErrorDTO(null,"administrationCentreId", "Administration centre is wrong")
		} else if (adminCentr.isAdministrationCentre) {
			return new ValidationErrorDTO(null,"administrationCentreId", "Site: $adminCentr.name is not administration centre")

		}

		return null
	}

	private static ValidationErrorDTO validatePaymentListIsNotEmpty(BankingDTO banking) {
		if (banking.payments.size() == 0) {
			return new ValidationErrorDTO("---", "payments", ERROR_NO_PAYMENTS_SELECTED)
		}
		return null
	}

	private static ValidationErrorDTO validateNotGateway(Banking banking) {

		BankingType bankingType = banking.getType()
		if (bankingType == GATEWAY || bankingType == AUTO_AMEX || bankingType == AUTO_MCVISA || bankingType == AUTO_OTHER) {
			return new ValidationErrorDTO(banking.id?.toString(), "id", ERROR_DELETE_GATEWAY)
		}
		return null
	}

	private static ValidationErrorDTO validateIsSettlementDateAfterLockedDate(LocalDate settlementDate, LocalDate lockedDate, String message) {
		if (settlementDate.compareTo(lockedDate) <= 0) {
			return new ValidationErrorDTO("---", "settlementDate", String.format(message, lockedDate.toString()))
		}
		return null
	}

	private static void updatePaymentInterface(PaymentInterface paymentInterface, PaymentDTO payment) {
		if (payment != null) {
			if (paymentInterface.paymentMethod.reconcilable) {
				paymentInterface.reconciled = payment.reconciled
			}
		} else {
			removePaymentFromBanking(paymentInterface)
		}
	}

	private static void removePaymentFromBanking(PaymentInterface pi) {
		pi.reconciled = false
		pi.banking = null
	}

	private static ValidationErrorDTO validateDateBankedAndPaymentDate (LocalDate dateBanked, LocalDate paymentDate) {
		if (dateBanked != null && paymentDate != null && dateBanked.isBefore(paymentDate)) {
			return new ValidationErrorDTO("---", "settlementDate", ERROR_DATE_BANKED_AFTER_DATE_PAID)
		}
		return null
	}
}
